<!DOCTYPE html><html lang="en"><head><title>thinkspace-html/test/controllers/content_update_test</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../../../"><meta name="groc-document-path" content="thinkspace-html/test/controllers/content_update_test"><meta name="groc-project-path" content="thinkspace-html/test/controllers/content_update_test.rb"><meta name="groc-branch-path" content="development"><meta name="groc-github-url" content="https://github.com/sixthedge/ethinkspace-api"><link rel="stylesheet" type="text/css" media="all" href="../../../assets/style.css"><script type="text/javascript" src="../../../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/sixthedge/ethinkspace-api/blob/development/thinkspace-html/test/controllers/content_update_test.rb">thinkspace-html/test/controllers/content_update_test.rb</a></div></div><div id="document"><a href="/" class="lodestar-link">Back to Guides</a><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-variable">$:</span>.push <span class="hljs-constant">ENV</span>[<span class="hljs-string">'TOTEM_TEST_HELPER'</span>]  <span class="hljs-comment"># add totem's test_helper.rb to the load path before requiring it</span>
<span class="hljs-keyword">require</span> <span class="hljs-string">'test_helper'</span>
<span class="hljs-keyword">require</span> <span class="hljs-string">'pp'</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiContentsControllerTest</span> <span class="hljs-inheritance">&lt; <span class="hljs-parent">ActionController::TestCase</span></span></span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">user_class</span>;</span>    <span class="hljs-constant">Thinkspace::Common::User</span>; <span class="hljs-keyword">end</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">phase_class</span>;</span>   <span class="hljs-constant">Thinkspace::Casespace::Phase</span>; <span class="hljs-keyword">end</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">content_class</span>;</span> <span class="hljs-constant">Thinkspace::Html::Content</span>; <span class="hljs-keyword">end</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">element_class</span>;</span> <span class="hljs-constant">Thinkspace::InputElement::Element</span>; <span class="hljs-keyword">end</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">record_not_found_error</span>;</span> <span class="hljs-constant">ActiveRecord::RecordNotFound</span>; <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_user</span><span class="hljs-params">(username)</span></span>
  user = user_class.find_by(<span class="hljs-symbol">name:</span> username)
  raise <span class="hljs-string">"User name <span class="hljs-subst">#{username.inspect}</span> not found."</span>  <span class="hljs-keyword">if</span> user.blank?
  user
<span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_phase</span><span class="hljs-params">(title)</span></span>
  phase = phase_class.find_by(<span class="hljs-symbol">title:</span> title)
  raise <span class="hljs-string">"Phase title <span class="hljs-subst">#{title.inspect}</span> not found."</span>  <span class="hljs-keyword">if</span> phase.blank?
  phase
<span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">phase_html_contents</span><span class="hljs-params">(phase)</span></span>
  phase_tools = phase.thinkspace_wips_casespace_phase_tools
  contents    = <span class="hljs-constant">Array</span>.new
  phase_tools.each <span class="hljs-keyword">do</span> |phase_tool|
    <span class="hljs-keyword">next</span> <span class="hljs-keyword">unless</span> phase_tool.toolable_type == content_class.name
    contents.push(phase_tool.toolable)
  <span class="hljs-keyword">end</span>
  raise <span class="hljs-string">"Phase <span class="hljs-subst">#{phase.title.inspect}</span> does not have html content"</span>  <span class="hljs-keyword">if</span> contents.blank?
  contents
<span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">timestamp</span></span>
  <span class="hljs-variable">@timestamp</span> ||= <span class="hljs-constant">Time</span>.now
<span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">html_content_hash</span><span class="hljs-params">(phase, content, username, options={})</span></span>
  create  = [options[<span class="hljs-symbol">:create</span>]].compact.flatten
  rename  = [options[<span class="hljs-symbol">:rename</span>]].compact.flatten
  destroy = [options[<span class="hljs-symbol">:destroy</span>]].compact.flatten

  json = {
    <span class="hljs-symbol">id:</span> content.id,
    <span class="hljs-string">'thinkspace/html/content'</span> =&gt; 
      {
        <span class="hljs-symbol">html_content:</span>           timestamp,
        <span class="hljs-symbol">input_elements_create:</span>  create,
        <span class="hljs-symbol">input_elements_rename:</span>  rename,
        <span class="hljs-symbol">input_elements_destroy:</span> destroy,
      }
  }
  hash = request_for(<span class="hljs-symbol">:put</span>, <span class="hljs-symbol">:update</span>, <span class="hljs-symbol">:api_content</span>, username, json)
  [hash, content]
<span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request_for</span><span class="hljs-params">(verb, action, named_route, username, json={})</span></span>
  user       = get_user(username)
  auth_token = user.authentication_token
  params     = json.merge({<span class="hljs-symbol">use_route:</span> named_route, <span class="hljs-symbol">auth_token:</span> auth_token})
  session    = {<span class="hljs-string">'totem.user_id'</span> =&gt; user.id}
  send(verb, action, params, session)
  body = <span class="hljs-variable">@response</span>.body
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">nil</span> <span class="hljs-keyword">if</span> body.blank?
  <span class="hljs-constant">HashWithIndifferentAccess</span>.new(<span class="hljs-constant">ActiveSupport::JSON</span>.decode(body))
<span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">content_record</span><span class="hljs-params">(hash)</span></span>
  hash[<span class="hljs-string">'thinkspace/html/content'</span>]
<span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_hash_input_element_values</span><span class="hljs-params">(hash, key)</span></span>
  values = hash[<span class="hljs-string">'thinkspace/input_element/elements'</span>].collect {|e| e[key]}
  key == <span class="hljs-symbol">:name</span> ? values.map {|v| v.to_sym}.sort <span class="hljs-symbol">:</span> values.sort
<span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_input_element_values</span><span class="hljs-params">(content, key)</span></span>
  values = content.thinkspace_input_element_elements.pluck(key)
  key == <span class="hljs-symbol">:name</span> ? values.map {|v| v.to_sym}.sort <span class="hljs-symbol">:</span> values.sort
<span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">assert_content_update</span><span class="hljs-params">(hash, phase, content)</span></span>
  record = content_record(hash)
  refute_nil record, <span class="hljs-string">'content is included'</span>
  assert_match(<span class="hljs-regexp">/<span class="hljs-subst">#{timestamp}</span>/</span>, record[<span class="hljs-symbol">:html_content</span>])
  assert_equal get_input_element_values(content, <span class="hljs-symbol">:name</span>), get_hash_input_element_values(hash, <span class="hljs-symbol">:name</span>), <span class="hljs-string">'element names to match'</span>
  element_ids = record[<span class="hljs-string">'thinkspace/input_element/element_ids'</span>].sort
  assert_equal get_input_element_values(content, <span class="hljs-symbol">:id</span>), element_ids, <span class="hljs-string">'element ids to match'</span>
  <span class="hljs-keyword">if</span> element_ids.present?
    assert_equal [phase.id], get_hash_input_element_values(hash, <span class="hljs-string">'thinkspace/wips/casespace/phase_id'</span>).uniq, <span class="hljs-string">'phase id to match'</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">assert_input_element_created</span><span class="hljs-params">(phase, names)</span></span>
  [names].flatten.each <span class="hljs-keyword">do</span> |hash|
    refute_nil element_class.find_by(<span class="hljs-symbol">phase_id:</span> phase.id, <span class="hljs-symbol">name:</span> hash[<span class="hljs-symbol">:name</span>])
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">assert_input_element_destroyed</span><span class="hljs-params">(ids)</span></span>
  [ids].flatten.each <span class="hljs-keyword">do</span> |hash|
    assert_raise(record_not_found_error) {element_class.find(hash[<span class="hljs-symbol">:id</span>])}
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">assert_error</span><span class="hljs-params">(hash)</span></span>
  assert_equal [<span class="hljs-string">'errors'</span>], hash.keys
<span class="hljs-keyword">end</span>

describe <span class="hljs-constant">Thinkspace::Html::Api::ContentsController</span>  <span class="hljs-keyword">do</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="upadate">UPADATE</h3></div></div></div><div class="segment"><div class="code"><div class="wrapper">  it <span class="hljs-string">'no input element changes'</span> <span class="hljs-keyword">do</span>
    phase         = get_phase(<span class="hljs-symbol">:phase_1_1_B</span>)
    content       = phase_html_contents(phase).first
    hash, content = html_content_hash(phase, content, <span class="hljs-symbol">:update_1</span>)
    assert_content_update(hash, phase, content)
  <span class="hljs-keyword">end</span>

  it <span class="hljs-string">'add input element name'</span> <span class="hljs-keyword">do</span>
    names         = [{<span class="hljs-symbol">name:</span> <span class="hljs-string">'xxxx'</span>}]
    phase         = get_phase(<span class="hljs-symbol">:phase_1_1_B</span>)
    content       = phase_html_contents(phase).first
    hash, content = html_content_hash(phase, content, <span class="hljs-symbol">:update_1</span>, <span class="hljs-symbol">create:</span> names) 
    assert_content_update(hash, phase, content)
    assert_input_element_created(phase, names)
  <span class="hljs-keyword">end</span>

  it <span class="hljs-string">'add multiple input element names'</span> <span class="hljs-keyword">do</span>
    names         = [{<span class="hljs-symbol">name:</span> <span class="hljs-string">'name_1'</span>}, {<span class="hljs-symbol">name:</span> <span class="hljs-string">'name_2'</span>}, {<span class="hljs-symbol">name:</span> <span class="hljs-string">'name_3'</span>}]
    phase         = get_phase(<span class="hljs-symbol">:phase_1_1_B</span>)
    content       = phase_html_contents(phase).first
    hash, content = html_content_hash(phase, content, <span class="hljs-symbol">:update_1</span>, <span class="hljs-symbol">create:</span> names)
    assert_content_update(hash, phase, content)
    assert_input_element_created(phase, names)
  <span class="hljs-keyword">end</span>

  it <span class="hljs-string">'remove input element id'</span> <span class="hljs-keyword">do</span>
    phase         = get_phase(<span class="hljs-symbol">:phase_1_1_B</span>)
    content       = phase_html_contents(phase).first
    element_ids   = get_input_element_values(content, <span class="hljs-symbol">:id</span>)
    id            = element_ids.first
    ids           = [{<span class="hljs-symbol">id:</span> id}]
    hash, content = html_content_hash(phase, content, <span class="hljs-symbol">:update_1</span>, <span class="hljs-symbol">destroy:</span> ids)
    assert_content_update(hash, phase, content)
    assert_input_element_destroyed(ids)
  <span class="hljs-keyword">end</span>

  it <span class="hljs-string">'remove multiple input element ids'</span> <span class="hljs-keyword">do</span>
    phase       = get_phase(<span class="hljs-symbol">:phase_1_1_B</span>)
    content     = phase_html_contents(phase).first
    element_ids = get_input_element_values(content, <span class="hljs-symbol">:id</span>)
    ids         = []
    element_ids.each <span class="hljs-keyword">do</span> |element_id|
      ids.push({<span class="hljs-symbol">id:</span> element_id})
    <span class="hljs-keyword">end</span>
    hash, content = html_content_hash(phase, content, <span class="hljs-symbol">:update_1</span>, <span class="hljs-symbol">destroy:</span> ids)
    assert_content_update(hash, phase, content)
    assert_input_element_destroyed(ids)
  <span class="hljs-keyword">end</span>

  it <span class="hljs-string">'add multiple names and remove multiple ids'</span> <span class="hljs-keyword">do</span>
    names         = [{<span class="hljs-symbol">name:</span> <span class="hljs-string">'name_1'</span>}, {<span class="hljs-symbol">name:</span> <span class="hljs-string">'name_2'</span>}, {<span class="hljs-symbol">name:</span> <span class="hljs-string">'name_3'</span>}]
    phase       = get_phase(<span class="hljs-symbol">:phase_1_1_B</span>)
    content     = phase_html_contents(phase).first
    element_ids = get_input_element_values(content, <span class="hljs-symbol">:id</span>)
    ids         = []
    element_ids.each <span class="hljs-keyword">do</span> |element_id|
      ids.push({<span class="hljs-symbol">id:</span> element_id})
    <span class="hljs-keyword">end</span>
    hash, content = html_content_hash(phase, content, <span class="hljs-symbol">:update_1</span>, <span class="hljs-symbol">create:</span> names, <span class="hljs-symbol">destroy:</span> ids)
    assert_content_update(hash, phase, content)
    assert_input_element_created(phase, names)
    assert_input_element_destroyed(ids)
  <span class="hljs-keyword">end</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="errors">ERRORS</h3></div></div></div><div class="segment"><div class="code"><div class="wrapper">  it <span class="hljs-string">'create element with missing name and rollback to original'</span> <span class="hljs-keyword">do</span>
    names                = [{<span class="hljs-symbol">name:</span> <span class="hljs-string">'name_1'</span>}, {<span class="hljs-symbol">name:</span> <span class="hljs-string">'name_2'</span>}, {<span class="hljs-symbol">name:</span> <span class="hljs-string">''</span>}]
    phase                = get_phase(<span class="hljs-symbol">:phase_1_1_B</span>)
    content              = phase_html_contents(phase).first
    original_element_ids = get_input_element_values(content, <span class="hljs-symbol">:id</span>)
    hash, content        = html_content_hash(phase, content, <span class="hljs-symbol">:update_1</span>, <span class="hljs-symbol">create:</span> names)
    assert_error(hash)
    assert_equal original_element_ids, get_input_element_values(content, <span class="hljs-symbol">:id</span>)
  <span class="hljs-keyword">end</span>

  it <span class="hljs-string">'destroy element with missing id and rollback to original'</span> <span class="hljs-keyword">do</span>
    phase                = get_phase(<span class="hljs-symbol">:phase_1_1_B</span>)
    content              = phase_html_contents(phase).first
    element_ids          = get_input_element_values(content, <span class="hljs-symbol">:id</span>)
    original_element_ids = get_input_element_values(content, <span class="hljs-symbol">:id</span>)
    ids                  = []
    element_ids.each <span class="hljs-keyword">do</span> |element_id|
      ids.push({<span class="hljs-symbol">id:</span> element_id})
    <span class="hljs-keyword">end</span>
    ids.push({<span class="hljs-symbol">id:</span> <span class="hljs-keyword">nil</span>})
    hash, content = html_content_hash(phase, content, <span class="hljs-symbol">:update_1</span>, <span class="hljs-symbol">destroy:</span> ids)
    assert_error(hash)
    assert_equal original_element_ids, get_input_element_values(content, <span class="hljs-symbol">:id</span>)
  <span class="hljs-keyword">end</span>

  it <span class="hljs-string">'element validation error adding identical names and rollback to original'</span> <span class="hljs-keyword">do</span>
    names                = [{<span class="hljs-symbol">name:</span> <span class="hljs-string">'name_1'</span>}, {<span class="hljs-symbol">name:</span> <span class="hljs-string">'name_2'</span>}, {<span class="hljs-symbol">name:</span> <span class="hljs-string">'name_1'</span>}]
    phase                = get_phase(<span class="hljs-symbol">:phase_1_1_B</span>)
    content              = phase_html_contents(phase).first
    original_element_ids = get_input_element_values(content, <span class="hljs-symbol">:id</span>)
    hash, content        = html_content_hash(phase, content, <span class="hljs-symbol">:update_1</span>, <span class="hljs-symbol">create:</span> names)
    assert_error(hash)
    assert_equal original_element_ids, get_input_element_values(content, <span class="hljs-symbol">:id</span>)
  <span class="hljs-keyword">end</span>

<span class="hljs-keyword">end</span>

<span class="hljs-keyword">end</span></div></div></div></div></body></html>