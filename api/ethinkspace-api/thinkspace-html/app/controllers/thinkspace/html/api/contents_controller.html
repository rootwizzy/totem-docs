<!DOCTYPE html><html lang="en"><head><title>thinkspace-html/app/controllers/thinkspace/html/api/contents_controller</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../../../../../../"><meta name="groc-document-path" content="thinkspace-html/app/controllers/thinkspace/html/api/contents_controller"><meta name="groc-project-path" content="thinkspace-html/app/controllers/thinkspace/html/api/contents_controller.rb"><meta name="groc-branch-path" content="development"><meta name="groc-github-url" content="https://github.com/sixthedge/ethinkspace-api"><link rel="stylesheet" type="text/css" media="all" href="../../../../../../assets/style.css"><script type="text/javascript" src="../../../../../../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/sixthedge/ethinkspace-api/blob/development/thinkspace-html/app/controllers/thinkspace/html/api/contents_controller.rb">thinkspace-html/app/controllers/thinkspace/html/api/contents_controller.rb</a></div></div><div id="document"><a href="/" class="lodestar-link">Back to Guides</a><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Thinkspace</span></span>
  <span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Html</span></span>
    <span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Api</span></span>
      <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContentsController</span> <span class="hljs-inheritance">&lt; </span>::<span class="hljs-title">Totem::Settings</span>.<span class="hljs-title">class</span>.<span class="hljs-title">thinkspace</span>.<span class="hljs-title">authorization_api_controller</span></span>
        load_and_authorize_resource <span class="hljs-class"><span class="hljs-keyword">class</span>: <span class="hljs-title">totem_controller_model_class</span></span>
        totem_action_authorize!
        totem_action_serializer_options

        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span></span>
          controller_render(<span class="hljs-variable">@content</span>)
        <span class="hljs-keyword">end</span>

        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">view</span></span>
          elements = <span class="hljs-variable">@content</span>.thinkspace_input_element_elements
          controller_render_view(elements)
        <span class="hljs-keyword">end</span>

        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">select</span></span>
          controller_render(<span class="hljs-variable">@contents</span>)
        <span class="hljs-keyword">end</span>

        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update</span></span>
          <span class="hljs-keyword">begin</span>
            <span class="hljs-variable">@content</span>.transaction <span class="hljs-keyword">do</span>
              html = params_root[<span class="hljs-symbol">:html_content</span>]
              hash = validate_html_content(html)
              process_element_changes(hash[<span class="hljs-symbol">:create</span>], hash[<span class="hljs-symbol">:delete</span>])
              <span class="hljs-variable">@content</span>.html_content = html
              controller_save_record(<span class="hljs-variable">@content</span>)
            <span class="hljs-keyword">end</span>
          <span class="hljs-keyword">rescue</span> <span class="hljs-constant">ProcessInputElementError</span>
            controller_render_error(<span class="hljs-variable">@content</span>)
          <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span>

        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">validate</span></span>
          html = params[<span class="hljs-symbol">:new_html</span>]
          controller_render_json validate_html_content(html)
        <span class="hljs-keyword">end</span>

        private</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="">#</h6>
<h3 id="process-content-element-changes">Process Content Element Changes</h3>
<h6 id="">#</h6></div></div><div class="code"><div class="wrapper">        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process_element_changes</span><span class="hljs-params">(elements_create, elements_delete, elements_rename = [])</span></span>
          created_radio_names = <span class="hljs-constant">Array</span>.new
          elements_create.each <span class="hljs-keyword">do</span> |attrs|
            name = attrs[<span class="hljs-symbol">:name</span>]
            type = attrs[<span class="hljs-symbol">:type</span>]
            raise_element_error({<span class="hljs-symbol">name:</span> <span class="hljs-string">'create element name is blank'</span>}) <span class="hljs-keyword">unless</span> name.present?
            <span class="hljs-keyword">if</span> type == <span class="hljs-string">'radio'</span>
              <span class="hljs-keyword">next</span> <span class="hljs-keyword">if</span> created_radio_names.<span class="hljs-keyword">include</span>?(name)
              created_radio_names.push(name)
            <span class="hljs-keyword">end</span>
            element = element_class.new
            raise_element_error({<span class="hljs-symbol">element_type:</span> <span class="hljs-string">"<span class="hljs-subst">#{type.inspect}</span> is not supported"</span>}) <span class="hljs-keyword">unless</span> element.is_supported_type?(type)
            element.componentable = <span class="hljs-variable">@content</span>
            element.name          = name
            element.element_type  = type
            raise_element_error(element.errors, name)  <span class="hljs-keyword">unless</span> element.save
          <span class="hljs-keyword">end</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>As of 06/05/2014, rename functionality has not been implemented on the ember side.</p></div></div><div class="code"><div class="wrapper">          elements_rename.each <span class="hljs-keyword">do</span> |attrs|
            element = get_existing_element(attrs[<span class="hljs-symbol">:id</span>])
            name    = attrs[<span class="hljs-symbol">:name</span>]
            raise_element_error({<span class="hljs-symbol">name:</span> <span class="hljs-string">'rename element name is blank'</span>}) <span class="hljs-keyword">unless</span> name.present?
            element.name     = name
            raise_element_error(element.errors, name)  <span class="hljs-keyword">unless</span> element.save
          <span class="hljs-keyword">end</span>
          elements_delete.each <span class="hljs-keyword">do</span> |attrs|
            id   = attrs[<span class="hljs-symbol">:id</span>]
            type = attrs[<span class="hljs-symbol">:type</span>]
            raise_element_error({<span class="hljs-symbol">id:</span> <span class="hljs-string">'destroy element id is blank'</span>}) <span class="hljs-keyword">unless</span> id.present?
            raise_element_error({<span class="hljs-symbol">id:</span> <span class="hljs-string">"destroy element type for id <span class="hljs-subst">#{id}</span> is blank"</span>}) <span class="hljs-keyword">unless</span> type.present?
            element = get_existing_element(id)
            raise_element_error(element.errors)  <span class="hljs-keyword">unless</span> element.destroy
          <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Find the element through the @content.  Will raise &#39;record not found&#39; error if id not valid for the content.</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_existing_element</span><span class="hljs-params">(id)</span></span>
          raise <span class="hljs-string">"Input element ID is blank for html content <span class="hljs-subst">#{<span class="hljs-variable">@content</span>.inspect}</span>."</span> <span class="hljs-keyword">unless</span> id.present?
          <span class="hljs-variable">@content</span>.thinkspace_input_element_elements.find(id)
        <span class="hljs-keyword">end</span>

        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">raise_element_error</span><span class="hljs-params">(messages, name=<span class="hljs-keyword">nil</span>)</span></span>
          messages.each <span class="hljs-keyword">do</span> |attribute, error|
            error += <span class="hljs-string">" [<span class="hljs-subst">#{name}</span>]"</span>  <span class="hljs-keyword">if</span> name.present? &amp;&amp; attribute == <span class="hljs-symbol">:name</span>
            <span class="hljs-variable">@content</span>.errors.add(attribute, error)
          <span class="hljs-keyword">end</span>
          raise <span class="hljs-constant">ProcessInputElementError</span>
        <span class="hljs-keyword">end</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h6 id="">#</h6>
<h3 id="validate-tags">Validate Tags</h3>
<h6 id="">#</h6></div></div><div class="code"><div class="wrapper">        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">validate_html_content</span><span class="hljs-params">(new_html)</span></span>
          action = totem_action_authorize.action
          raise_access_denied_exception(<span class="hljs-string">'Params and record authable to not match.'</span>, action, <span class="hljs-variable">@content</span>) <span class="hljs-keyword">unless</span> totem_action_authorize.params_authable == totem_action_authorize.record_authable
          raise_access_denied_exception(<span class="hljs-string">'Cannot update html content.'</span>, action, <span class="hljs-variable">@content</span>) <span class="hljs-keyword">unless</span> totem_action_authorize.can_update_record_authable?</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Parse the old and new html tags into an array of nokogiri tag nodes.</p></div></div><div class="code"><div class="wrapper">          element_tags = element_class.element_tags
          custom_tags  = element_class.custom_tags
          image_tags   = <span class="hljs-symbol">:img</span>

          old_tags = parse_html_tags(<span class="hljs-variable">@content</span>.html_content, <span class="hljs-symbol">element:</span> element_tags, <span class="hljs-symbol">custom:</span> custom_tags)  <span class="hljs-comment"># custom tags used for create/delete info only</span>
          new_tags = parse_html_tags(new_html,              <span class="hljs-symbol">element:</span> element_tags, <span class="hljs-symbol">custom:</span> custom_tags, <span class="hljs-symbol">image:</span> image_tags)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get any new html nokogiri errors not related to a custom tag.</p></div></div><div class="code"><div class="wrapper">          ng_errors  = new_tags[<span class="hljs-symbol">:errors</span>].select {|e| !([<span class="hljs-number">801</span>, <span class="hljs-number">76</span>].<span class="hljs-keyword">include</span>?(e.code) &amp;&amp; custom_tags.<span class="hljs-keyword">include</span>?(e.str1))}
          errors     = ng_errors.collect {|e| {<span class="hljs-symbol">message:</span> e.message, <span class="hljs-symbol">line:</span> e.line, <span class="hljs-symbol">key:</span> <span class="hljs-symbol">:base</span>} }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Validate the tags and collect the errors.</p></div></div><div class="code"><div class="wrapper">          errors += validate_element_tags new_tags[<span class="hljs-symbol">:element</span>]
          errors += validate_custom_tags  new_tags[<span class="hljs-symbol">:custom</span>]
          errors += validate_image_tags   new_tags[<span class="hljs-symbol">:image</span>]</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Sort errors by line number.</p></div></div><div class="code"><div class="wrapper">          errors  = errors.sort_by {|e| e[<span class="hljs-symbol">:line</span>]}

          hash = <span class="hljs-constant">Hash</span>.new
          <span class="hljs-keyword">case</span> action
          <span class="hljs-keyword">when</span> <span class="hljs-symbol">:validate</span>
            <span class="hljs-keyword">if</span> errors.present?
              hash[<span class="hljs-symbol">:errors</span>] = errors
            <span class="hljs-keyword">else</span>
              element     = get_element_tag_changes(old_tags[<span class="hljs-symbol">:element</span>], new_tags[<span class="hljs-symbol">:element</span>])
              custom      = get_custom_tag_changes(old_tags[<span class="hljs-symbol">:custom</span>], new_tags[<span class="hljs-symbol">:custom</span>])
              all_changes = element[<span class="hljs-symbol">:create</span>] + element[<span class="hljs-symbol">:delete</span>] + custom[<span class="hljs-symbol">:create</span>] + custom[<span class="hljs-symbol">:delete</span>]
              hash[<span class="hljs-symbol">:changes</span>] = all_changes.sort_by { |change| [change[<span class="hljs-symbol">:line</span>], change[<span class="hljs-symbol">:action</span>]] }
            <span class="hljs-keyword">end</span>
          <span class="hljs-keyword">when</span> <span class="hljs-symbol">:update</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the html was &#39;validated&#39; before saving, then there should not be any errors.
If there are errors and since this is an update, treat them as model validation errors.</p></div></div><div class="code"><div class="wrapper">            <span class="hljs-keyword">if</span> errors.present?
              errors.each <span class="hljs-keyword">do</span> |error|
                attribute = error[<span class="hljs-symbol">:key</span>] || <span class="hljs-symbol">:base</span>
                message   = error[<span class="hljs-symbol">:message</span>]
                <span class="hljs-variable">@content</span>.errors.add(attribute, message)
              <span class="hljs-keyword">end</span>
              raise <span class="hljs-constant">ProcessInputElementError</span>
            <span class="hljs-keyword">else</span>
              changes = get_element_tag_changes(old_tags[<span class="hljs-symbol">:element</span>], new_tags[<span class="hljs-symbol">:element</span>])
              hash[<span class="hljs-symbol">:create</span>] = changes[<span class="hljs-symbol">:create</span>]
              hash[<span class="hljs-symbol">:delete</span>] = changes[<span class="hljs-symbol">:delete</span>]
            <span class="hljs-keyword">end</span>
          <span class="hljs-keyword">else</span>
            raise <span class="hljs-string">"Unknown content validation action [<span class="hljs-subst">#{action.inspect}</span>]."</span>
          <span class="hljs-keyword">end</span>

          hash
        <span class="hljs-keyword">end</span>

        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse_html_tags</span><span class="hljs-params">(html_string, tag_hash)</span></span>
          html = <span class="hljs-constant">::Nokogiri::HTML</span>.fragment(html_string) <span class="hljs-keyword">do</span> |config|
            config.strict.nonet
          <span class="hljs-keyword">end</span>
          hash = <span class="hljs-constant">Hash</span>.new
          tag_hash.each <span class="hljs-keyword">do</span> |key, tags|
            hash[key] = get_tags(html, tags)
          <span class="hljs-keyword">end</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Check for tags that Nokogiri deems invalid, yet are actually valid.
=&gt; Could not find an option for the parser to skip things like &#39;canvas&#39; tags, so handling it this way.</p></div></div><div class="code"><div class="wrapper">          errors          = []
          skip_error_tags = [<span class="hljs-string">'canvas'</span>]
          html.errors.each <span class="hljs-keyword">do</span> |error|
            errors &lt;&lt; error <span class="hljs-keyword">unless</span> skip_error_tags.<span class="hljs-keyword">include</span>?(error.str1) <span class="hljs-comment"># error.str1 # 'canvas'</span>
          <span class="hljs-keyword">end</span>

          hash[<span class="hljs-symbol">:errors</span>] = errors
          hash
        <span class="hljs-keyword">end</span>

        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">validate_element_tags</span><span class="hljs-params">(element_tags)</span></span>
          errors           = <span class="hljs-constant">Array</span>.new
          radio_tags, tags = element_tags.partition {|tag| tag[<span class="hljs-string">'type'</span>] == <span class="hljs-string">'radio'</span>}
          validate_element_radio_tags(radio_tags, tags, errors)
          names    = get_tags_attribute(tags, <span class="hljs-symbol">:name</span>)
          bad_tags = tags.find_all {|tag| tag[<span class="hljs-string">'name'</span>].present? &amp;&amp; names.count(tag[<span class="hljs-string">'name'</span>]) &gt; <span class="hljs-number">1</span>}
          add_tag_errors(errors, bad_tags, <span class="hljs-string">":tag.name :tag_name is a duplicate"</span>)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>the below validations apply to all tags</p></div></div><div class="code"><div class="wrapper">          tags    += radio_tags
          bad_tags = tags.find_all {|tag| invalid_tag_name(tag[<span class="hljs-string">'name'</span>])}
          add_tag_errors(errors, bad_tags, <span class="hljs-string">":tag.name :tag_name is invalid"</span>)
          bad_tags = tags.find_all {|tag| tag[<span class="hljs-string">'id'</span>].present?}
          add_tag_errors(errors, bad_tags, <span class="hljs-string">":tag.name should not contain an id in :tag_name"</span>)
          input_types = [<span class="hljs-string">'text'</span>, <span class="hljs-string">'checkbox'</span>, <span class="hljs-string">'radio'</span>]
          bad_tags    = tags.find_all {|tag| tag.name == <span class="hljs-string">'input'</span> &amp;&amp; tag[<span class="hljs-string">'type'</span>].present? &amp;&amp; !input_types.<span class="hljs-keyword">include</span>?(tag[<span class="hljs-string">'type'</span>])}
          add_tag_errors(errors, bad_tags, <span class="hljs-string">":tag.name :tag_type invalid -&gt; valid: <span class="hljs-subst">#{input_types.inspect}</span>"</span>, <span class="hljs-symbol">sub:</span> <span class="hljs-symbol">:type</span>)
          validate_tags_terminated(tags, errors)
          errors
        <span class="hljs-keyword">end</span>

        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">validate_element_radio_tags</span><span class="hljs-params">(radio_tags, other_tags, errors)</span></span>
          radio_values = <span class="hljs-constant">Hash</span>.new
          radio_names  = <span class="hljs-constant">Hash</span>.new(<span class="hljs-number">0</span>)
          radio_tags.each <span class="hljs-keyword">do</span> |tag|
            name  = tag[<span class="hljs-string">'name'</span>]
            value = tag[<span class="hljs-string">'value'</span>]
            radio_values[name] ||= <span class="hljs-constant">Array</span>.new
            add_tag_errors(errors, tag, <span class="hljs-string">":tag.name :tag_type :tag_name must include a value attribute"</span>, <span class="hljs-symbol">sub:</span> <span class="hljs-symbol">:type</span>)  <span class="hljs-keyword">if</span> value.blank?
            add_tag_errors(errors, tag, <span class="hljs-string">":tag.name :tag_type :tag_name has a duplicate value <span class="hljs-subst">#{value.inspect}</span>"</span>, <span class="hljs-symbol">sub:</span> <span class="hljs-symbol">:type</span>)  <span class="hljs-keyword">if</span> radio_values[name].<span class="hljs-keyword">include</span>?(value)
            radio_values[name].push(value)
            radio_names[name] += <span class="hljs-number">1</span>
          <span class="hljs-keyword">end</span>
          other_names = other_tags.map {|tag| tag[<span class="hljs-string">'name'</span>]}
          names       = radio_names.keys.sort
          dup_names   = names &amp; other_names
          bad_tags    = radio_tags.select {|tag| dup_names.<span class="hljs-keyword">include</span>?(tag[<span class="hljs-string">'name'</span>])}
          add_tag_errors(errors, bad_tags, <span class="hljs-string">":tag.name :tag_type :tag_name is a duplicate of another input name"</span>, <span class="hljs-symbol">sub:</span> <span class="hljs-symbol">:type</span>)
          (names - dup_names).each <span class="hljs-keyword">do</span> |name|
            count = radio_names[name]
            <span class="hljs-keyword">next</span> <span class="hljs-keyword">if</span> count &gt; <span class="hljs-number">1</span>
            bad_tags = radio_tags.select {|tag| tag[<span class="hljs-string">'name'</span>] == name}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Add a validation error for a single radio button (e.g. one radio input with a name).
Technically, a single radio button would be ok but should be a checkbox instead.</p></div></div><div class="code"><div class="wrapper">            add_tag_errors(errors, bad_tags, <span class="hljs-string">":tag.name :tag_type :tag_name is a single radio button"</span>, <span class="hljs-symbol">sub:</span> <span class="hljs-symbol">:type</span>)
          <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span>

        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">validate_custom_tags</span><span class="hljs-params">(tags)</span></span>
          errors = <span class="hljs-constant">Array</span>.new
          tags.each <span class="hljs-keyword">do</span> |tag|
            tag_errors = <span class="hljs-constant">Array</span>.new
            id         = tag[<span class="hljs-string">'id'</span>]
            type       = tag[<span class="hljs-string">'type'</span>]
            name       = tag[<span class="hljs-string">'name'</span>]
            template   = tag[<span class="hljs-string">'template'</span>]
            add_tag_errors(tag_errors, tag, <span class="hljs-string">":tag.name :tag_name should not contain an id"</span>)  <span class="hljs-keyword">if</span> id.present?
            add_tag_errors(tag_errors, tag, <span class="hljs-string">":tag.name :tag_name is invalid"</span>)  <span class="hljs-keyword">if</span> invalid_tag_name(name)
            add_tag_errors(tag_errors, tag, <span class="hljs-string">":tag.name :tag_template is invalid"</span>, <span class="hljs-symbol">sub:</span> <span class="hljs-symbol">:template</span>)  <span class="hljs-keyword">if</span> template.present? &amp;&amp; invalid_tag_name(template)
            valid_types     = element_class.custom_tag_types(tag.name)
            valid_templates = element_class.custom_tag_type_templates(tag.name, type)
            <span class="hljs-keyword">unless</span> valid_types.<span class="hljs-keyword">include</span>?(type)
              add_tag_errors(tag_errors, tag, <span class="hljs-string">":tag.name :tag_type invalid -&gt; valid: <span class="hljs-subst">#{valid_types.inspect}</span>"</span>, <span class="hljs-symbol">sub:</span> <span class="hljs-symbol">:type</span>)
            <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">if</span> template.present? &amp;&amp; !valid_templates.<span class="hljs-keyword">include</span>?(template)
              add_tag_errors(tag_errors, tag, <span class="hljs-string">":tag.name :tag_template invalid -&gt; valid: <span class="hljs-subst">#{valid_templates.inspect}</span>"</span>, <span class="hljs-symbol">sub:</span> <span class="hljs-symbol">:template</span>)
            <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">if</span> tag_errors.blank?  <span class="hljs-comment"># do specific checks if tag is clean to this point</span>
              <span class="hljs-keyword">case</span> type.to_sym
              <span class="hljs-keyword">when</span> <span class="hljs-symbol">:carry_forward</span>
                element = totem_action_authorize.get_carry_forward_elements(name)
                add_tag_errors(tag_errors, tag, <span class="hljs-string">":tag.name :tag_name for :tag_type not found"</span>, <span class="hljs-symbol">sub:</span> <span class="hljs-symbol">:type</span>)  <span class="hljs-keyword">if</span> element.blank?
              <span class="hljs-keyword">else</span>
                add_tag_errors(tag_errors, tag, <span class="hljs-string">":tag.name :tag_type not supported"</span>, <span class="hljs-symbol">sub:</span> <span class="hljs-symbol">:type</span>)
              <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">end</span>
            errors += tag_errors
          <span class="hljs-keyword">end</span>
          validate_tags_terminated(tags, errors)
          errors
        <span class="hljs-keyword">end</span>

        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">validate_tags_terminated</span><span class="hljs-params">(tags, errors)</span></span>
          tags.each <span class="hljs-keyword">do</span> |tag|
            child = tag.child
            add_tag_errors(errors, tag, <span class="hljs-string">":tag.name not terminated for :tag_name (add: &lt;/<span class="hljs-subst">#{tag.name}</span>&gt;)"</span>)  <span class="hljs-keyword">unless</span> child.<span class="hljs-keyword">nil</span>?
          <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span>

        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">validate_image_tags</span><span class="hljs-params">(tags)</span></span>
          errors = <span class="hljs-constant">Array</span>.new
          tags.each <span class="hljs-keyword">do</span> |tag|
            src = tag[<span class="hljs-string">'src'</span>]
            add_tag_errors(errors, tag, <span class="hljs-string">"Image tag should use 'https:'"</span>)  <span class="hljs-keyword">if</span> src.match(<span class="hljs-string">'http:'</span>)
          <span class="hljs-keyword">end</span>
          errors
        <span class="hljs-keyword">end</span>

        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_element_tag_changes</span><span class="hljs-params">(old_tags, new_tags)</span></span>
          hash          = <span class="hljs-constant">Hash</span>.new
          old_names     = get_tags_attribute(old_tags, <span class="hljs-symbol">:name</span>).compact.uniq
          new_names     = get_tags_attribute(new_tags, <span class="hljs-symbol">:name</span>).compact.uniq
          create_names  = new_names - old_names
          delete_names  = old_names - new_names
          create_tags   = get_tags_with_attribute_values(new_tags, <span class="hljs-symbol">:name</span>, create_names)
          hash[<span class="hljs-symbol">:create</span>] = create_tags.collect { |tag| {<span class="hljs-symbol">name:</span> tag[<span class="hljs-string">'name'</span>], <span class="hljs-symbol">type:</span> tag[<span class="hljs-string">'type'</span>] || tag.name, <span class="hljs-symbol">line:</span> tag.line, <span class="hljs-symbol">action:</span> <span class="hljs-symbol">:create</span>, <span class="hljs-symbol">tag:</span> tag.name} }
          hash[<span class="hljs-symbol">:delete</span>] = <span class="hljs-constant">Array</span>.new
          deleted_radio_names = <span class="hljs-constant">Array</span>.new
          delete_names.each <span class="hljs-keyword">do</span> |name|
            elements = <span class="hljs-variable">@content</span>.thinkspace_input_element_elements.where(<span class="hljs-symbol">name:</span> name)
            raise <span class="hljs-constant">ProcessInputElementError</span>, <span class="hljs-string">"Element <span class="hljs-subst">#{name.inspect}</span> does not exist for content [id: <span class="hljs-subst">#{<span class="hljs-variable">@content</span>.id}</span>."</span>  <span class="hljs-keyword">if</span> elements.blank?
            raise <span class="hljs-constant">ProcessInputElementError</span>, <span class="hljs-string">"More than one element exists for <span class="hljs-subst">#{name.inspect}</span> content [id: <span class="hljs-subst">#{<span class="hljs-variable">@content</span>.id}</span>."</span>  <span class="hljs-keyword">if</span> elements.length &gt; <span class="hljs-number">1</span>
            element = elements.first
            tags    = get_tags_with_attribute_values(old_tags, <span class="hljs-symbol">:name</span>, name)
            raise <span class="hljs-constant">ProcessInputElementError</span>, <span class="hljs-string">"Delete element not found with name <span class="hljs-subst">#{name.inspect}</span> content [id: <span class="hljs-subst">#{<span class="hljs-variable">@content</span>.id}</span>."</span>  <span class="hljs-keyword">if</span> tags.blank?
            types = tags.map {|tag| tag[<span class="hljs-string">'type'</span>]}.uniq
            <span class="hljs-keyword">if</span> types == [<span class="hljs-string">'radio'</span>]
              <span class="hljs-keyword">next</span> <span class="hljs-keyword">if</span> deleted_radio_names.<span class="hljs-keyword">include</span>?(name)
              deleted_radio_names.push(name)
            <span class="hljs-keyword">else</span>
              raise <span class="hljs-constant">ProcessInputElementError</span>, <span class="hljs-string">"Delete has multiple elements with the same name <span class="hljs-subst">#{name.inspect}</span> content [id: <span class="hljs-subst">#{<span class="hljs-variable">@content</span>.id}</span>."</span>  <span class="hljs-keyword">if</span> tags.length &gt; <span class="hljs-number">1</span>
            <span class="hljs-keyword">end</span>
            tag = tags.first
            hash[<span class="hljs-symbol">:delete</span>].push({<span class="hljs-symbol">id:</span> element.id, <span class="hljs-symbol">name:</span> element.name, <span class="hljs-symbol">type:</span> element.element_type, <span class="hljs-symbol">line:</span> tag.line, <span class="hljs-symbol">action:</span> <span class="hljs-symbol">:delete</span>, <span class="hljs-symbol">tag:</span> tag.name})
          <span class="hljs-keyword">end</span>
          hash
        <span class="hljs-keyword">end</span>

        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_custom_tag_changes</span><span class="hljs-params">(old_tags, new_tags)</span></span>
          hash          = <span class="hljs-constant">Hash</span>.new
          old_names     = get_tags_attribute(old_tags, <span class="hljs-symbol">:name</span>).compact.uniq
          new_names     = get_tags_attribute(new_tags, <span class="hljs-symbol">:name</span>).compact.uniq
          create_names  = new_names - old_names
          delete_names  = old_names - new_names
          create_tags   = get_tags_with_attribute_values(new_tags, <span class="hljs-symbol">:name</span>, create_names)
          hash[<span class="hljs-symbol">:create</span>] = create_tags.collect { |tag| {<span class="hljs-symbol">name:</span> tag[<span class="hljs-string">'name'</span>], <span class="hljs-symbol">type:</span> tag[<span class="hljs-string">'type'</span>] || tag.name, <span class="hljs-symbol">line:</span> tag.line, <span class="hljs-symbol">action:</span> <span class="hljs-symbol">:create</span>, <span class="hljs-symbol">tag:</span> tag.name} }
          delete_tags   = get_tags_with_attribute_values(old_tags, <span class="hljs-symbol">:name</span>, delete_names)
          hash[<span class="hljs-symbol">:delete</span>] = delete_tags.collect { |tag| {<span class="hljs-symbol">name:</span> tag[<span class="hljs-string">'name'</span>], <span class="hljs-symbol">type:</span> tag[<span class="hljs-string">'type'</span>] || tag.name, <span class="hljs-symbol">line:</span> tag.line, <span class="hljs-symbol">action:</span> <span class="hljs-symbol">:delete</span>, <span class="hljs-symbol">tag:</span> tag.name} }
          hash
        <span class="hljs-keyword">end</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="">#</h2>
<h3 id="validate-tag-helpers">Validate Tag Helpers</h3>
<h2 id="">#</h2></div></div><div class="code"><div class="wrapper">        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">valid_tag_name</span><span class="hljs-params">(name)</span></span>
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span> <span class="hljs-keyword">if</span> name.blank?
          name.match(<span class="hljs-regexp">/^[a-zA-Z0-9_-]+$/</span>)
        <span class="hljs-keyword">end</span>

        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">invalid_tag_name</span><span class="hljs-params">(name)</span>;</span> !valid_tag_name(name); <span class="hljs-keyword">end</span>

        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_tags</span><span class="hljs-params">(*args)</span></span>
          html      = args.shift
          tag_names = [args].flatten
          tags      = <span class="hljs-constant">Array</span>.new
          tag_names.each <span class="hljs-keyword">do</span> |tag_name|
            tags += html.css(tag_name.to_s)
          <span class="hljs-keyword">end</span>
          tags
        <span class="hljs-keyword">end</span>

        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_tags_attribute</span><span class="hljs-params">(tags, key)</span></span>
          key = key.to_s
          tags.collect {|tag| tag[key]}
        <span class="hljs-keyword">end</span>

        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_tags_with_attribute_values</span><span class="hljs-params">(tags, key, values)</span></span>
          key    = key.to_s
          values = [values].flatten.compact
          tags.select {|tag| values.<span class="hljs-keyword">include</span>?(tag[key])}
        <span class="hljs-keyword">end</span>

        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_tag_errors</span><span class="hljs-params">(errors, tags, message, options={})</span></span>
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> tags.blank?
          [tags].flatten.each <span class="hljs-keyword">do</span> |tag|
            msg = tag_error_message(tag, message, options)
            key = options[<span class="hljs-symbol">:sub</span>].blank? ? <span class="hljs-symbol">:name</span> <span class="hljs-symbol">:</span> [options[<span class="hljs-symbol">:sub</span>]].flatten.join(<span class="hljs-string">'_'</span>).to_sym
            errors.push({<span class="hljs-symbol">message:</span> msg, <span class="hljs-symbol">line:</span> tag.line, <span class="hljs-symbol">key:</span> key})
          <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span>

        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tag_error_message</span><span class="hljs-params">(tag, message, options={})</span></span>
          subs = [options[<span class="hljs-symbol">:sub</span>], <span class="hljs-symbol">:name</span>].flatten.compact.uniq
          subs.uniq.each <span class="hljs-keyword">do</span> |sub|
            sub_string = <span class="hljs-string">":tag_<span class="hljs-subst">#{sub}</span>"</span>
            sub_value  = tag[sub.to_s]
            sub_value  = sub_value.present? ? sub_value.inspect <span class="hljs-symbol">:</span> <span class="hljs-string">'missing'</span>
            message    = message.sub(sub_string, <span class="hljs-string">"<span class="hljs-subst">#{sub}</span> <span class="hljs-subst">#{sub_value}</span>"</span>)
          <span class="hljs-keyword">end</span>
          message = message.sub(<span class="hljs-string">':tag.name'</span>, tag.name)  <span class="hljs-keyword">if</span> message.match(<span class="hljs-string">':tag.name'</span>)
          message
        <span class="hljs-keyword">end</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h1 id="this-would-only-be-an-approximation-based-on-whether-the-tag-paths-are-the-same">This would only be an approximation based on whether the tag paths are the same</h1>
<h1 id="and-only-work-for-simple-changes-does-not-work-when-multiple-changes-impact-a-tag39s-path">and only work for simple changes.  Does not work when multiple changes impact a tag&#39;s path.</h1>
<p>def get_tag_rename_changes(old_tags, new_tags, deleted_names)
  renamed      = Array.new
  delete_tags  = get_tags_with_attribute_values(old_tags, :name, deleted_names).compact.uniq
  delete_paths = delete_tags.collect {|tag| tag.path}
  delete_paths.each do |path|
    rename_tags  = new_tags.select {|tag| path == tag.path}
    if rename_tags.present?
      rename_names = get_tags_attribute(rename_tags, :name)
      renamed     += rename_names
    end
  end
  renamed.compact.uniq
end</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="">#</h2>
<h3 id="general-helpers">General Helpers</h3>
<h2 id="">#</h2></div></div><div class="code"><div class="wrapper">        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">element_class</span>;</span> <span class="hljs-constant">Thinkspace::InputElement::Element</span>; <span class="hljs-keyword">end</span>

        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProcessInputElementError</span> <span class="hljs-inheritance">&lt; <span class="hljs-parent">StandardError</span></span>;</span> <span class="hljs-keyword">end</span>

      <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span></div></div></div></div></body></html>