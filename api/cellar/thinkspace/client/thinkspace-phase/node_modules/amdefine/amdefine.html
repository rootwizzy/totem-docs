<!DOCTYPE html><html lang="en"><head><title>thinkspace/client/thinkspace-phase/node_modules/amdefine/amdefine</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../../../../../"><meta name="groc-document-path" content="thinkspace/client/thinkspace-phase/node_modules/amdefine/amdefine"><meta name="groc-project-path" content="src/thinkspace/client/thinkspace-phase/node_modules/amdefine/amdefine.js"><meta name="groc-branch-path" content="master"><meta name="groc-github-url" content="https://github.com/sixthedge/cellar"><link rel="stylesheet" type="text/css" media="all" href="../../../../../assets/style.css"><script type="text/javascript" src="../../../../../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/sixthedge/cellar/blob/master/src/thinkspace/client/thinkspace-phase/node_modules/amdefine/amdefine.js">src/thinkspace/client/thinkspace-phase/node_modules/amdefine/amdefine.js</a></div></div><div id="document"><a href="/" class="lodestar-link">Back to Guides</a><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'> license amdefine 1.0.1 Copyright (c) 2011-2016, The Dojo Foundation All Rights Reserved.
Available via the MIT or new BSD license.
see: <a href="http://github.com/jrburke/amdefine">http://github.com/jrburke/amdefine</a> for details</span></p>
<p>vim: et:ts=4:sw=4:sts=4</p></div></div><div class="code"><div class="wrapper"><span class="hljs-comment">/*jslint node: true */</span>
<span class="hljs-comment">/*global module, process */</span>
<span class="hljs-pi">'use strict'</span>;</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Creates a define for node.</p>
<p>Parameters:</p>
<ul>
<li><p><strong>module must be an Object.</strong><br/>(the &quot;module&quot; object that is defined by Node for the current module.)</p>
</li>
<li><p><strong>requireFn is optional and must be a Function.</strong><br/>(. Node&#39;s require function for the current module. It only needs to be passed in Node versions before 0.5, when module.require did not exist.)</p>
</li>
</ul>
<p><strong>Returns a Function</strong><br/>(a define function that is usable for the current node module.)</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">amdefine</span>(<span class="hljs-params">module, requireFn</span>) </span>{
<span class="hljs-pi">    'use strict'</span>;
    <span class="hljs-keyword">var</span> defineCache = {},
        loaderCache = {},
        alreadyCalled = <span class="hljs-literal">false</span>,
        path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>),
        makeRequire, stringRequire;</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Trims the . and .. from an array of path segments.
It will keep a leading path segment if a .. will become
the first path segment, to help with module name lookups,
which act like paths, but can be remapped. But the end result,
all paths that use this function should look normalized.
NOTE: this method MODIFIES the input array.</p>
<p>Parameters:</p>
<ul>
<li><strong>ary must be an Array.</strong><br/>(the array of path segments.)</li>
</ul></div></div><div class="code"><div class="wrapper">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trimDots</span>(<span class="hljs-params">ary</span>) </span>{
        <span class="hljs-keyword">var</span> i, part;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; ary[i]; i+= <span class="hljs-number">1</span>) {
            part = ary[i];
            <span class="hljs-keyword">if</span> (part === <span class="hljs-string">'.'</span>) {
                ary.splice(i, <span class="hljs-number">1</span>);
                i -= <span class="hljs-number">1</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (part === <span class="hljs-string">'..'</span>) {
                <span class="hljs-keyword">if</span> (i === <span class="hljs-number">1</span> &amp;&amp; (ary[<span class="hljs-number">2</span>] === <span class="hljs-string">'..'</span> || ary[<span class="hljs-number">0</span>] === <span class="hljs-string">'..'</span>)) {
                    <span class="hljs-comment">//End of the line. Keep at least one non-dot</span>
                    <span class="hljs-comment">//path segment at the front so it can be mapped</span>
                    <span class="hljs-comment">//correctly to disk. Otherwise, there is likely</span>
                    <span class="hljs-comment">//no path mapping for a path starting with '..'.</span>
                    <span class="hljs-comment">//This can still fail, but catches the most reasonable</span>
                    <span class="hljs-comment">//uses of ..</span>
                    <span class="hljs-keyword">break</span>;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) {
                    ary.splice(i - <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
                    i -= <span class="hljs-number">2</span>;
                }
            }
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">normalize</span>(<span class="hljs-params">name, baseName</span>) </span>{
        <span class="hljs-keyword">var</span> baseParts;

        <span class="hljs-comment">//Adjust any relative paths.</span>
        <span class="hljs-keyword">if</span> (name &amp;&amp; name.charAt(<span class="hljs-number">0</span>) === <span class="hljs-string">'.'</span>) {
            <span class="hljs-comment">//If have a base name, try to normalize against it,</span>
            <span class="hljs-comment">//otherwise, assume it is a top-level require that will</span>
            <span class="hljs-comment">//be relative to baseUrl in the end.</span>
            <span class="hljs-keyword">if</span> (baseName) {
                baseParts = baseName.split(<span class="hljs-string">'/'</span>);
                baseParts = baseParts.slice(<span class="hljs-number">0</span>, baseParts.length - <span class="hljs-number">1</span>);
                baseParts = baseParts.concat(name.split(<span class="hljs-string">'/'</span>));
                trimDots(baseParts);
                name = baseParts.join(<span class="hljs-string">'/'</span>);
            }
        }

        <span class="hljs-keyword">return</span> name;
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Create the normalize() function passed to a loader plugin&#39;s
normalize method.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeNormalize</span>(<span class="hljs-params">relName</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
            <span class="hljs-keyword">return</span> normalize(name, relName);
        };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeLoad</span>(<span class="hljs-params">id</span>) </span>{
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load</span>(<span class="hljs-params">value</span>) </span>{
            loaderCache[id] = value;
        }

        load.fromText = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id, text</span>) </span>{
            <span class="hljs-comment">//This one is difficult because the text can/probably uses</span>
            <span class="hljs-comment">//define, and any relative paths and requires should be relative</span>
            <span class="hljs-comment">//to that id was it would be found on disk. But this would require</span>
            <span class="hljs-comment">//bootstrapping a module/require fairly deeply from node core.</span>
            <span class="hljs-comment">//Not sure how best to go about that yet.</span>
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'amdefine does not implement load.fromText'</span>);
        };

        <span class="hljs-keyword">return</span> load;
    }

    makeRequire = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">systemRequire, exports, module, relId</span>) </span>{
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">amdRequire</span>(<span class="hljs-params">deps, callback</span>) </span>{
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> deps === <span class="hljs-string">'string'</span>) {
                <span class="hljs-comment">//Synchronous, single module require('')</span>
                <span class="hljs-keyword">return</span> stringRequire(systemRequire, exports, <span class="hljs-built_in">module</span>, deps, relId);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">//Array of dependencies with a callback.</span>

                <span class="hljs-comment">//Convert the dependencies to modules.</span>
                deps = deps.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">depName</span>) </span>{
                    <span class="hljs-keyword">return</span> stringRequire(systemRequire, exports, <span class="hljs-built_in">module</span>, depName, relId);
                });

                <span class="hljs-comment">//Wait for next tick to call back the require call.</span>
                <span class="hljs-keyword">if</span> (callback) {
                    process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                        callback.apply(<span class="hljs-literal">null</span>, deps);
                    });
                }
            }
        }

        amdRequire.toUrl = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">filePath</span>) </span>{
            <span class="hljs-keyword">if</span> (filePath.indexOf(<span class="hljs-string">'.'</span>) === <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">return</span> normalize(filePath, path.dirname(<span class="hljs-built_in">module</span>.filename));
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> filePath;
            }
        };

        <span class="hljs-keyword">return</span> amdRequire;
    };

    <span class="hljs-comment">//Favor explicit value, passed in if the module wants to support Node 0.4.</span>
    requireFn = requireFn || <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">req</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">module</span>.require.apply(<span class="hljs-built_in">module</span>, <span class="hljs-built_in">arguments</span>);
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">runFactory</span>(<span class="hljs-params">id, deps, factory</span>) </span>{
        <span class="hljs-keyword">var</span> r, e, m, result;

        <span class="hljs-keyword">if</span> (id) {
            e = loaderCache[id] = {};
            m = {
                id: id,
                uri: __filename,
                exports: e
            };
            r = makeRequire(requireFn, e, m, id);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">//Only support one define call per file</span>
            <span class="hljs-keyword">if</span> (alreadyCalled) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'amdefine with no module ID cannot be called more than once per file.'</span>);
            }
            alreadyCalled = <span class="hljs-literal">true</span>;

            <span class="hljs-comment">//Use the real variables from node</span>
            <span class="hljs-comment">//Use module.exports for exports, since</span>
            <span class="hljs-comment">//the exports in here is amdefine exports.</span>
            e = <span class="hljs-built_in">module</span>.exports;
            m = <span class="hljs-built_in">module</span>;
            r = makeRequire(requireFn, e, m, <span class="hljs-built_in">module</span>.id);
        }

        <span class="hljs-comment">//If there are dependencies, they are strings, so need</span>
        <span class="hljs-comment">//to convert them to dependency values.</span>
        <span class="hljs-keyword">if</span> (deps) {
            deps = deps.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">depName</span>) </span>{
                <span class="hljs-keyword">return</span> r(depName);
            });
        }

        <span class="hljs-comment">//Call the factory with the right dependencies.</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> factory === <span class="hljs-string">'function'</span>) {
            result = factory.apply(m.exports, deps);
        } <span class="hljs-keyword">else</span> {
            result = factory;
        }

        <span class="hljs-keyword">if</span> (result !== <span class="hljs-literal">undefined</span>) {
            m.exports = result;
            <span class="hljs-keyword">if</span> (id) {
                loaderCache[id] = m.exports;
            }
        }
    }

    stringRequire = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">systemRequire, exports, module, id, relId</span>) </span>{
        <span class="hljs-comment">//Split the ID by a ! so that</span>
        <span class="hljs-keyword">var</span> index = id.indexOf(<span class="hljs-string">'!'</span>),
            originalId = id,
            prefix, plugin;

        <span class="hljs-keyword">if</span> (index === -<span class="hljs-number">1</span>) {
            id = normalize(id, relId);

            <span class="hljs-comment">//Straight module lookup. If it is one of the special dependencies,</span>
            <span class="hljs-comment">//deal with it, otherwise, delegate to node.</span>
            <span class="hljs-keyword">if</span> (id === <span class="hljs-string">'require'</span>) {
                <span class="hljs-keyword">return</span> makeRequire(systemRequire, exports, <span class="hljs-built_in">module</span>, relId);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (id === <span class="hljs-string">'exports'</span>) {
                <span class="hljs-keyword">return</span> exports;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (id === <span class="hljs-string">'module'</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">module</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (loaderCache.hasOwnProperty(id)) {
                <span class="hljs-keyword">return</span> loaderCache[id];
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (defineCache[id]) {
                runFactory.apply(<span class="hljs-literal">null</span>, defineCache[id]);
                <span class="hljs-keyword">return</span> loaderCache[id];
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span>(systemRequire) {
                    <span class="hljs-keyword">return</span> systemRequire(originalId);
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'No module with ID: '</span> + id);
                }
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">//There is a plugin in play.</span>
            prefix = id.substring(<span class="hljs-number">0</span>, index);
            id = id.substring(index + <span class="hljs-number">1</span>, id.length);

            plugin = stringRequire(systemRequire, exports, <span class="hljs-built_in">module</span>, prefix, relId);

            <span class="hljs-keyword">if</span> (plugin.normalize) {
                id = plugin.normalize(id, makeNormalize(relId));
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">//Normalize the ID normally.</span>
                id = normalize(id, relId);
            }

            <span class="hljs-keyword">if</span> (loaderCache[id]) {
                <span class="hljs-keyword">return</span> loaderCache[id];
            } <span class="hljs-keyword">else</span> {
                plugin.load(id, makeRequire(systemRequire, exports, <span class="hljs-built_in">module</span>, relId), makeLoad(id), {});

                <span class="hljs-keyword">return</span> loaderCache[id];
            }
        }
    };

    <span class="hljs-comment">//Create a define function specific to the module asking for amdefine.</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">define</span>(<span class="hljs-params">id, deps, factory</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(id)) {
            factory = deps;
            deps = id;
            id = <span class="hljs-literal">undefined</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> id !== <span class="hljs-string">'string'</span>) {
            factory = id;
            id = deps = <span class="hljs-literal">undefined</span>;
        }

        <span class="hljs-keyword">if</span> (deps &amp;&amp; !<span class="hljs-built_in">Array</span>.isArray(deps)) {
            factory = deps;
            deps = <span class="hljs-literal">undefined</span>;
        }

        <span class="hljs-keyword">if</span> (!deps) {
            deps = [<span class="hljs-string">'require'</span>, <span class="hljs-string">'exports'</span>, <span class="hljs-string">'module'</span>];
        }

        <span class="hljs-comment">//Set up properties for this module. If an ID, then use</span>
        <span class="hljs-comment">//internal cache. If no ID, then use the external variables</span>
        <span class="hljs-comment">//for this node module.</span>
        <span class="hljs-keyword">if</span> (id) {
            <span class="hljs-comment">//Put the module in deep freeze until there is a</span>
            <span class="hljs-comment">//require call for it.</span>
            defineCache[id] = [id, deps, factory];
        } <span class="hljs-keyword">else</span> {
            runFactory(id, deps, factory);
        }
    }

    <span class="hljs-comment">//define.require, which has access to all the values in the</span>
    <span class="hljs-comment">//cache. Useful for AMD modules that all have IDs in the file,</span>
    <span class="hljs-comment">//but need to finally export a value to node based on one of those</span>
    <span class="hljs-comment">//IDs.</span>
    define.require = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) </span>{
        <span class="hljs-keyword">if</span> (loaderCache[id]) {
            <span class="hljs-keyword">return</span> loaderCache[id];
        }

        <span class="hljs-keyword">if</span> (defineCache[id]) {
            runFactory.apply(<span class="hljs-literal">null</span>, defineCache[id]);
            <span class="hljs-keyword">return</span> loaderCache[id];
        }
    };

    define.amd = {};

    <span class="hljs-keyword">return</span> define;
}

<span class="hljs-built_in">module</span>.exports = amdefine;</div></div></div></div></body></html>