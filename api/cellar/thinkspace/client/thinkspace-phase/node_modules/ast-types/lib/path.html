<!DOCTYPE html><html lang="en"><head><title>thinkspace/client/thinkspace-phase/node_modules/ast-types/lib/path</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../../../../../../"><meta name="groc-document-path" content="thinkspace/client/thinkspace-phase/node_modules/ast-types/lib/path"><meta name="groc-project-path" content="src/thinkspace/client/thinkspace-phase/node_modules/ast-types/lib/path.js"><meta name="groc-branch-path" content="master"><meta name="groc-github-url" content="https://github.com/sixthedge/cellar"><link rel="stylesheet" type="text/css" media="all" href="../../../../../../assets/style.css"><script type="text/javascript" src="../../../../../../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/sixthedge/cellar/blob/master/src/thinkspace/client/thinkspace-phase/node_modules/ast-types/lib/path.js">src/thinkspace/client/thinkspace-phase/node_modules/ast-types/lib/path.js</a></div></div><div id="document"><a href="/" class="lodestar-link">Back to Guides</a><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> Ap = <span class="hljs-built_in">Array</span>.prototype;
<span class="hljs-keyword">var</span> slice = Ap.slice;
<span class="hljs-keyword">var</span> map = Ap.map;
<span class="hljs-keyword">var</span> Op = <span class="hljs-built_in">Object</span>.prototype;
<span class="hljs-keyword">var</span> hasOwn = Op.hasOwnProperty;

<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fork</span>) </span>{
    <span class="hljs-keyword">var</span> types = fork.use(<span class="hljs-built_in">require</span>(<span class="hljs-string">"./types"</span>));
    <span class="hljs-keyword">var</span> isArray = types.builtInTypes.array;
    <span class="hljs-keyword">var</span> isNumber = types.builtInTypes.number;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Path</span>(<span class="hljs-params">value, parentPath, name</span>) </span>{
        <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Path)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Path constructor cannot be invoked without 'new'"</span>);
        }

        <span class="hljs-keyword">if</span> (parentPath) {
            <span class="hljs-keyword">if</span> (!(parentPath <span class="hljs-keyword">instanceof</span> Path)) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
            }
        } <span class="hljs-keyword">else</span> {
            parentPath = <span class="hljs-literal">null</span>;
            name = <span class="hljs-literal">null</span>;
        }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The value encapsulated by this Path, generally equal to
parentPath.value[name] if we have a parentPath.</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">this</span>.value = value;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The immediate parent Path of this Path.</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">this</span>.parentPath = parentPath;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The name of the property of parentPath.value through which this
Path&#39;s value was reached.</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">this</span>.name = name;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Calling path.get(&quot;child&quot;) multiple times always returns the same
child Path object, for both performance and consistency reasons.</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">this</span>.__childCache = <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">var</span> Pp = Path.prototype;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getChildCache</span>(<span class="hljs-params">path</span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Lazily create the child cache. This also cheapens cache
invalidation, since you can just reset path.__childCache to null.</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">return</span> path.__childCache || (path.__childCache = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>));
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getChildPath</span>(<span class="hljs-params">path, name</span>) </span>{
        <span class="hljs-keyword">var</span> cache = getChildCache(path);
        <span class="hljs-keyword">var</span> actualChildValue = path.getValueProperty(name);
        <span class="hljs-keyword">var</span> childPath = cache[name];
        <span class="hljs-keyword">if</span> (!hasOwn.call(cache, name) ||</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Ensure consistency between cache and reality.</p></div></div><div class="code"><div class="wrapper">          childPath.value !== actualChildValue) {
            childPath = cache[name] = <span class="hljs-keyword">new</span> path.constructor(
              actualChildValue, path, name
            );
        }
        <span class="hljs-keyword">return</span> childPath;
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This method is designed to be overridden by subclasses that need to
handle missing properties, etc.</p></div></div><div class="code"><div class="wrapper">    Pp.getValueProperty = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getValueProperty</span>(<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.value[name];
    };

    Pp.get = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">var</span> path = <span class="hljs-keyword">this</span>;
        <span class="hljs-keyword">var</span> names = <span class="hljs-built_in">arguments</span>;
        <span class="hljs-keyword">var</span> count = names.length;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; count; ++i) {
            path = getChildPath(path, names[i]);
        }

        <span class="hljs-keyword">return</span> path;
    };

    Pp.each = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">each</span>(<span class="hljs-params">callback, context</span>) </span>{
        <span class="hljs-keyword">var</span> childPaths = [];
        <span class="hljs-keyword">var</span> len = <span class="hljs-keyword">this</span>.value.length;
        <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Collect all the original child paths before invoking the callback.</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) {
            <span class="hljs-keyword">if</span> (hasOwn.call(<span class="hljs-keyword">this</span>.value, i)) {
                childPaths[i] = <span class="hljs-keyword">this</span>.get(i);
            }
        }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Invoke the callback on just the original child paths, regardless of
any modifications made to the array by the callback. I chose these
semantics over cleverly invoking the callback on new elements because
this way is much easier to reason about.</p></div></div><div class="code"><div class="wrapper">        context = context || <span class="hljs-keyword">this</span>;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; ++i) {
            <span class="hljs-keyword">if</span> (hasOwn.call(childPaths, i)) {
                callback.call(context, childPaths[i]);
            }
        }
    };

    Pp.map = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">map</span>(<span class="hljs-params">callback, context</span>) </span>{
        <span class="hljs-keyword">var</span> result = [];

        <span class="hljs-keyword">this</span>.each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">childPath</span>) </span>{
            result.push(callback.call(<span class="hljs-keyword">this</span>, childPath));
        }, context);

        <span class="hljs-keyword">return</span> result;
    };

    Pp.filter = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filter</span>(<span class="hljs-params">callback, context</span>) </span>{
        <span class="hljs-keyword">var</span> result = [];

        <span class="hljs-keyword">this</span>.each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">childPath</span>) </span>{
            <span class="hljs-keyword">if</span> (callback.call(<span class="hljs-keyword">this</span>, childPath)) {
                result.push(childPath);
            }
        }, context);

        <span class="hljs-keyword">return</span> result;
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">emptyMoves</span>(<span class="hljs-params"></span>) </span>{}
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMoves</span>(<span class="hljs-params">path, offset, start, end</span>) </span>{
        isArray.assert(path.value);

        <span class="hljs-keyword">if</span> (offset === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> emptyMoves;
        }

        <span class="hljs-keyword">var</span> length = path.value.length;
        <span class="hljs-keyword">if</span> (length &lt; <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">return</span> emptyMoves;
        }

        <span class="hljs-keyword">var</span> argc = <span class="hljs-built_in">arguments</span>.length;
        <span class="hljs-keyword">if</span> (argc === <span class="hljs-number">2</span>) {
            start = <span class="hljs-number">0</span>;
            end = length;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (argc === <span class="hljs-number">3</span>) {
            start = <span class="hljs-built_in">Math</span>.max(start, <span class="hljs-number">0</span>);
            end = length;
        } <span class="hljs-keyword">else</span> {
            start = <span class="hljs-built_in">Math</span>.max(start, <span class="hljs-number">0</span>);
            end = <span class="hljs-built_in">Math</span>.min(end, length);
        }

        isNumber.assert(start);
        isNumber.assert(end);

        <span class="hljs-keyword">var</span> moves = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);
        <span class="hljs-keyword">var</span> cache = getChildCache(path);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = start; i &lt; end; ++i) {
            <span class="hljs-keyword">if</span> (hasOwn.call(path.value, i)) {
                <span class="hljs-keyword">var</span> childPath = path.get(i);
                <span class="hljs-keyword">if</span> (childPath.name !== i) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
                }
                <span class="hljs-keyword">var</span> newIndex = i + offset;
                childPath.name = newIndex;
                moves[newIndex] = childPath;
                <span class="hljs-keyword">delete</span> cache[i];
            }
        }

        <span class="hljs-keyword">delete</span> cache.length;

        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> newIndex <span class="hljs-keyword">in</span> moves) {
                <span class="hljs-keyword">var</span> childPath = moves[newIndex];
                <span class="hljs-keyword">if</span> (childPath.name !== +newIndex) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
                }
                cache[newIndex] = childPath;
                path.value[newIndex] = childPath.value;
            }
        };
    }

    Pp.shift = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shift</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> move = getMoves(<span class="hljs-keyword">this</span>, -<span class="hljs-number">1</span>);
        <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">this</span>.value.shift();
        move();
        <span class="hljs-keyword">return</span> result;
    };

    Pp.unshift = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unshift</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">var</span> move = getMoves(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>.length);
        <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">this</span>.value.unshift.apply(<span class="hljs-keyword">this</span>.value, <span class="hljs-built_in">arguments</span>);
        move();
        <span class="hljs-keyword">return</span> result;
    };

    Pp.push = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">push</span>(<span class="hljs-params">node</span>) </span>{
        isArray.assert(<span class="hljs-keyword">this</span>.value);
        <span class="hljs-keyword">delete</span> getChildCache(<span class="hljs-keyword">this</span>).length
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.value.push.apply(<span class="hljs-keyword">this</span>.value, <span class="hljs-built_in">arguments</span>);
    };

    Pp.pop = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pop</span>(<span class="hljs-params"></span>) </span>{
        isArray.assert(<span class="hljs-keyword">this</span>.value);
        <span class="hljs-keyword">var</span> cache = getChildCache(<span class="hljs-keyword">this</span>);
        <span class="hljs-keyword">delete</span> cache[<span class="hljs-keyword">this</span>.value.length - <span class="hljs-number">1</span>];
        <span class="hljs-keyword">delete</span> cache.length;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.value.pop();
    };

    Pp.insertAt = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertAt</span>(<span class="hljs-params">index, node</span>) </span>{
        <span class="hljs-keyword">var</span> argc = <span class="hljs-built_in">arguments</span>.length;
        <span class="hljs-keyword">var</span> move = getMoves(<span class="hljs-keyword">this</span>, argc - <span class="hljs-number">1</span>, index);
        <span class="hljs-keyword">if</span> (move === emptyMoves) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        }

        index = <span class="hljs-built_in">Math</span>.max(index, <span class="hljs-number">0</span>);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; argc; ++i) {
            <span class="hljs-keyword">this</span>.value[index + i - <span class="hljs-number">1</span>] = <span class="hljs-built_in">arguments</span>[i];
        }

        move();

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    };

    Pp.insertBefore = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertBefore</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">var</span> pp = <span class="hljs-keyword">this</span>.parentPath;
        <span class="hljs-keyword">var</span> argc = <span class="hljs-built_in">arguments</span>.length;
        <span class="hljs-keyword">var</span> insertAtArgs = [<span class="hljs-keyword">this</span>.name];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; argc; ++i) {
            insertAtArgs.push(<span class="hljs-built_in">arguments</span>[i]);
        }
        <span class="hljs-keyword">return</span> pp.insertAt.apply(pp, insertAtArgs);
    };

    Pp.insertAfter = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertAfter</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">var</span> pp = <span class="hljs-keyword">this</span>.parentPath;
        <span class="hljs-keyword">var</span> argc = <span class="hljs-built_in">arguments</span>.length;
        <span class="hljs-keyword">var</span> insertAtArgs = [<span class="hljs-keyword">this</span>.name + <span class="hljs-number">1</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; argc; ++i) {
            insertAtArgs.push(<span class="hljs-built_in">arguments</span>[i]);
        }
        <span class="hljs-keyword">return</span> pp.insertAt.apply(pp, insertAtArgs);
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">repairRelationshipWithParent</span>(<span class="hljs-params">path</span>) </span>{
        <span class="hljs-keyword">if</span> (!(path <span class="hljs-keyword">instanceof</span> Path)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
        }

        <span class="hljs-keyword">var</span> pp = path.parentPath;
        <span class="hljs-keyword">if</span> (!pp) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Orphan paths have no relationship to repair.</p></div></div><div class="code"><div class="wrapper">            <span class="hljs-keyword">return</span> path;
        }

        <span class="hljs-keyword">var</span> parentValue = pp.value;
        <span class="hljs-keyword">var</span> parentCache = getChildCache(pp);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Make sure parentCache[path.name] is populated.</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">if</span> (parentValue[path.name] === path.value) {
            parentCache[path.name] = path;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isArray.check(parentValue)) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Something caused path.name to become out of date, so attempt to
recover by searching for path.value in parentValue.</p></div></div><div class="code"><div class="wrapper">            <span class="hljs-keyword">var</span> i = parentValue.indexOf(path.value);
            <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) {
                parentCache[path.name = i] = path;
            }
        } <span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If path.value disagrees with parentValue[path.name], and
path.name is not an array index, let path.value become the new
parentValue[path.name] and update parentCache accordingly.</p></div></div><div class="code"><div class="wrapper">            parentValue[path.name] = path.value;
            parentCache[path.name] = path;
        }

        <span class="hljs-keyword">if</span> (parentValue[path.name] !== path.value) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
        }
        <span class="hljs-keyword">if</span> (path.parentPath.get(path.name) !== path) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
        }

        <span class="hljs-keyword">return</span> path;
    }

    Pp.replace = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">replace</span>(<span class="hljs-params">replacement</span>) </span>{
        <span class="hljs-keyword">var</span> results = [];
        <span class="hljs-keyword">var</span> parentValue = <span class="hljs-keyword">this</span>.parentPath.value;
        <span class="hljs-keyword">var</span> parentCache = getChildCache(<span class="hljs-keyword">this</span>.parentPath);
        <span class="hljs-keyword">var</span> count = <span class="hljs-built_in">arguments</span>.length;

        repairRelationshipWithParent(<span class="hljs-keyword">this</span>);

        <span class="hljs-keyword">if</span> (isArray.check(parentValue)) {
            <span class="hljs-keyword">var</span> originalLength = parentValue.length;
            <span class="hljs-keyword">var</span> move = getMoves(<span class="hljs-keyword">this</span>.parentPath, count - <span class="hljs-number">1</span>, <span class="hljs-keyword">this</span>.name + <span class="hljs-number">1</span>);

            <span class="hljs-keyword">var</span> spliceArgs = [<span class="hljs-keyword">this</span>.name, <span class="hljs-number">1</span>];
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; count; ++i) {
                spliceArgs.push(<span class="hljs-built_in">arguments</span>[i]);
            }

            <span class="hljs-keyword">var</span> splicedOut = parentValue.splice.apply(parentValue, spliceArgs);

            <span class="hljs-keyword">if</span> (splicedOut[<span class="hljs-number">0</span>] !== <span class="hljs-keyword">this</span>.value) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
            }
            <span class="hljs-keyword">if</span> (parentValue.length !== (originalLength - <span class="hljs-number">1</span> + count)) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
            }

            move();

            <span class="hljs-keyword">if</span> (count === <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.value;
                <span class="hljs-keyword">delete</span> parentCache[<span class="hljs-keyword">this</span>.name];
                <span class="hljs-keyword">this</span>.__childCache = <span class="hljs-literal">null</span>;

            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (parentValue[<span class="hljs-keyword">this</span>.name] !== replacement) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
                }

                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.value !== replacement) {
                    <span class="hljs-keyword">this</span>.value = replacement;
                    <span class="hljs-keyword">this</span>.__childCache = <span class="hljs-literal">null</span>;
                }

                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; ++i) {
                    results.push(<span class="hljs-keyword">this</span>.parentPath.get(<span class="hljs-keyword">this</span>.name + i));
                }

                <span class="hljs-keyword">if</span> (results[<span class="hljs-number">0</span>] !== <span class="hljs-keyword">this</span>) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
                }
            }

        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count === <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.value !== replacement) {
                <span class="hljs-keyword">this</span>.__childCache = <span class="hljs-literal">null</span>;
            }
            <span class="hljs-keyword">this</span>.value = parentValue[<span class="hljs-keyword">this</span>.name] = replacement;
            results.push(<span class="hljs-keyword">this</span>);

        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">delete</span> parentValue[<span class="hljs-keyword">this</span>.name];
            <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.value;
            <span class="hljs-keyword">this</span>.__childCache = <span class="hljs-literal">null</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Leave this path cached as parentCache[this.name], even though
it no longer has a value defined.</p></div></div><div class="code"><div class="wrapper">        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Could not replace path"</span>);
        }

        <span class="hljs-keyword">return</span> results;
    };

    <span class="hljs-keyword">return</span> Path;
};</div></div></div></div></body></html>