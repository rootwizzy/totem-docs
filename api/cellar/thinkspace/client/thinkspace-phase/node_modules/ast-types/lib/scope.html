<!DOCTYPE html><html lang="en"><head><title>thinkspace/client/thinkspace-phase/node_modules/ast-types/lib/scope</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../../../../../../"><meta name="groc-document-path" content="thinkspace/client/thinkspace-phase/node_modules/ast-types/lib/scope"><meta name="groc-project-path" content="src/thinkspace/client/thinkspace-phase/node_modules/ast-types/lib/scope.js"><meta name="groc-branch-path" content="master"><meta name="groc-github-url" content="https://github.com/sixthedge/cellar"><link rel="stylesheet" type="text/css" media="all" href="../../../../../../assets/style.css"><script type="text/javascript" src="../../../../../../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/sixthedge/cellar/blob/master/src/thinkspace/client/thinkspace-phase/node_modules/ast-types/lib/scope.js">src/thinkspace/client/thinkspace-phase/node_modules/ast-types/lib/scope.js</a></div></div><div id="document"><a href="/" class="lodestar-link">Back to Guides</a><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> hasOwn = <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty;

<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fork</span>) </span>{
    <span class="hljs-keyword">var</span> types = fork.use(<span class="hljs-built_in">require</span>(<span class="hljs-string">"./types"</span>));
    <span class="hljs-keyword">var</span> Type = types.Type;
    <span class="hljs-keyword">var</span> namedTypes = types.namedTypes;
    <span class="hljs-keyword">var</span> Node = namedTypes.Node;
    <span class="hljs-keyword">var</span> Expression = namedTypes.Expression;
    <span class="hljs-keyword">var</span> isArray = types.builtInTypes.array;
    <span class="hljs-keyword">var</span> b = types.builders;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Scope</span>(<span class="hljs-params">path, parentScope</span>) </span>{
        <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Scope)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Scope constructor cannot be invoked without 'new'"</span>);
        }
        <span class="hljs-keyword">if</span> (!(path <span class="hljs-keyword">instanceof</span> fork.use(<span class="hljs-built_in">require</span>(<span class="hljs-string">"./node-path"</span>)))) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
        }
        ScopeType.assert(path.value);

        <span class="hljs-keyword">var</span> depth;

        <span class="hljs-keyword">if</span> (parentScope) {
            <span class="hljs-keyword">if</span> (!(parentScope <span class="hljs-keyword">instanceof</span> Scope)) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
            }
            depth = parentScope.depth + <span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> {
            parentScope = <span class="hljs-literal">null</span>;
            depth = <span class="hljs-number">0</span>;
        }

        <span class="hljs-built_in">Object</span>.defineProperties(<span class="hljs-keyword">this</span>, {
            path: { value: path },
            node: { value: path.value },
            isGlobal: { value: !parentScope, enumerable: <span class="hljs-literal">true</span> },
            depth: { value: depth },
            parent: { value: parentScope },
            bindings: { value: {} },
            types: { value: {} },
        });
    }

    <span class="hljs-keyword">var</span> scopeTypes = [</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Program nodes introduce global scopes.</p></div></div><div class="code"><div class="wrapper">        namedTypes.Program,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Function is the supertype of FunctionExpression,
FunctionDeclaration, ArrowExpression, etc.</p></div></div><div class="code"><div class="wrapper">        namedTypes.Function,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>In case you didn&#39;t know, the caught parameter shadows any variable
of the same name in an outer scope.</p></div></div><div class="code"><div class="wrapper">        namedTypes.CatchClause
    ];

    <span class="hljs-keyword">var</span> ScopeType = Type.or.apply(Type, scopeTypes);

    Scope.isEstablishedBy = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">return</span> ScopeType.check(node);
    };

    <span class="hljs-keyword">var</span> Sp = Scope.prototype;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Will be overridden after an instance lazily calls scanScope.</p></div></div><div class="code"><div class="wrapper">    Sp.didScan = <span class="hljs-literal">false</span>;

    Sp.declares = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">this</span>.scan();
        <span class="hljs-keyword">return</span> hasOwn.call(<span class="hljs-keyword">this</span>.bindings, name);
    };

    Sp.declaresType = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">this</span>.scan();
        <span class="hljs-keyword">return</span> hasOwn.call(<span class="hljs-keyword">this</span>.types, name);
    };

    Sp.declareTemporary = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prefix</span>) </span>{
        <span class="hljs-keyword">if</span> (prefix) {
            <span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/^[a-z$_]/i</span>.test(prefix)) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
            }
        } <span class="hljs-keyword">else</span> {
            prefix = <span class="hljs-string">"t$"</span>;
        }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Include this.depth in the name to make sure the name does not
collide with any variables in nested/enclosing scopes.</p></div></div><div class="code"><div class="wrapper">        prefix += <span class="hljs-keyword">this</span>.depth.toString(<span class="hljs-number">36</span>) + <span class="hljs-string">"$"</span>;

        <span class="hljs-keyword">this</span>.scan();

        <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.declares(prefix + index)) {
            ++index;
        }

        <span class="hljs-keyword">var</span> name = prefix + index;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.bindings[name] = types.builders.identifier(name);
    };

    Sp.injectTemporary = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">identifier, init</span>) </span>{
        identifier || (identifier = <span class="hljs-keyword">this</span>.declareTemporary());

        <span class="hljs-keyword">var</span> bodyPath = <span class="hljs-keyword">this</span>.path.get(<span class="hljs-string">"body"</span>);
        <span class="hljs-keyword">if</span> (namedTypes.BlockStatement.check(bodyPath.value)) {
            bodyPath = bodyPath.get(<span class="hljs-string">"body"</span>);
        }

        bodyPath.unshift(
          b.variableDeclaration(
            <span class="hljs-string">"var"</span>,
            [b.variableDeclarator(identifier, init || <span class="hljs-literal">null</span>)]
          )
        );

        <span class="hljs-keyword">return</span> identifier;
    };

    Sp.scan = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">force</span>) </span>{
        <span class="hljs-keyword">if</span> (force || !<span class="hljs-keyword">this</span>.didScan) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> name <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.bindings) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Empty out this.bindings, just in cases.</p></div></div><div class="code"><div class="wrapper">                <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.bindings[name];
            }
            scanScope(<span class="hljs-keyword">this</span>.path, <span class="hljs-keyword">this</span>.bindings, <span class="hljs-keyword">this</span>.types);
            <span class="hljs-keyword">this</span>.didScan = <span class="hljs-literal">true</span>;
        }
    };

    Sp.getBindings = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>.scan();
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.bindings;
    };

    Sp.getTypes = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>.scan();
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.types;
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scanScope</span>(<span class="hljs-params">path, bindings, scopeTypes</span>) </span>{
        <span class="hljs-keyword">var</span> node = path.value;
        ScopeType.assert(node);

        <span class="hljs-keyword">if</span> (namedTypes.CatchClause.check(node)) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A catch clause establishes a new scope but the only variable
bound in that scope is the catch parameter. Any other
declarations create bindings in the outer scope.</p></div></div><div class="code"><div class="wrapper">            addPattern(path.get(<span class="hljs-string">"param"</span>), bindings);

        } <span class="hljs-keyword">else</span> {
            recursiveScanScope(path, bindings, scopeTypes);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recursiveScanScope</span>(<span class="hljs-params">path, bindings, scopeTypes</span>) </span>{
        <span class="hljs-keyword">var</span> node = path.value;

        <span class="hljs-keyword">if</span> (path.parent &amp;&amp;
          namedTypes.FunctionExpression.check(path.parent.node) &amp;&amp;
          path.parent.node.id) {
            addPattern(path.parent.get(<span class="hljs-string">"id"</span>), bindings);
        }

        <span class="hljs-keyword">if</span> (!node) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>None of the remaining cases matter if node is falsy.</p></div></div><div class="code"><div class="wrapper">        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isArray.check(node)) {
            path.each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">childPath</span>) </span>{
                recursiveScanChild(childPath, bindings, scopeTypes);
            });

        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (namedTypes.Function.check(node)) {
            path.get(<span class="hljs-string">"params"</span>).each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">paramPath</span>) </span>{
                addPattern(paramPath, bindings);
            });

            recursiveScanChild(path.get(<span class="hljs-string">"body"</span>), bindings, scopeTypes);

        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (namedTypes.TypeAlias &amp;&amp; namedTypes.TypeAlias.check(node)) {
            addTypePattern(path.get(<span class="hljs-string">"id"</span>), scopeTypes);

        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (namedTypes.VariableDeclarator.check(node)) {
            addPattern(path.get(<span class="hljs-string">"id"</span>), bindings);
            recursiveScanChild(path.get(<span class="hljs-string">"init"</span>), bindings, scopeTypes);

        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">"ImportSpecifier"</span> ||
          node.type === <span class="hljs-string">"ImportNamespaceSpecifier"</span> ||
          node.type === <span class="hljs-string">"ImportDefaultSpecifier"</span>) {
            addPattern(</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Esprima used to use the .name field to refer to the local
binding identifier for ImportSpecifier nodes, but .id for
ImportNamespaceSpecifier and ImportDefaultSpecifier nodes.
ESTree/Acorn/ESpree use .local for all three node types.</p></div></div><div class="code"><div class="wrapper">              path.get(node.local ? <span class="hljs-string">"local"</span> :
                node.name ? <span class="hljs-string">"name"</span> : <span class="hljs-string">"id"</span>),
              bindings
            );

        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Node.check(node) &amp;&amp; !Expression.check(node)) {
            types.eachField(node, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, child</span>) </span>{
                <span class="hljs-keyword">var</span> childPath = path.get(name);
                <span class="hljs-keyword">if</span> (!pathHasValue(childPath, child)) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
                }
                recursiveScanChild(childPath, bindings, scopeTypes);
            });
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pathHasValue</span>(<span class="hljs-params">path, value</span>) </span>{
        <span class="hljs-keyword">if</span> (path.value === value) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Empty arrays are probably produced by defaults.emptyArray, in which
case is makes sense to regard them as equivalent, if not ===.</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(path.value) &amp;&amp;
          path.value.length === <span class="hljs-number">0</span> &amp;&amp;
          <span class="hljs-built_in">Array</span>.isArray(value) &amp;&amp;
          value.length === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recursiveScanChild</span>(<span class="hljs-params">path, bindings, scopeTypes</span>) </span>{
        <span class="hljs-keyword">var</span> node = path.value;

        <span class="hljs-keyword">if</span> (!node || Expression.check(node)) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Ignore falsy values and Expressions.</p></div></div><div class="code"><div class="wrapper">        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (namedTypes.FunctionDeclaration.check(node) &amp;&amp;
                   node.id !== <span class="hljs-literal">null</span>) {
            addPattern(path.get(<span class="hljs-string">"id"</span>), bindings);

        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (namedTypes.ClassDeclaration &amp;&amp;
          namedTypes.ClassDeclaration.check(node)) {
            addPattern(path.get(<span class="hljs-string">"id"</span>), bindings);

        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ScopeType.check(node)) {
            <span class="hljs-keyword">if</span> (namedTypes.CatchClause.check(node)) {
                <span class="hljs-keyword">var</span> catchParamName = node.param.name;
                <span class="hljs-keyword">var</span> hadBinding = hasOwn.call(bindings, catchParamName);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Any declarations that occur inside the catch body that do
not have the same name as the catch parameter should count
as bindings in the outer scope.</p></div></div><div class="code"><div class="wrapper">                recursiveScanScope(path.get(<span class="hljs-string">"body"</span>), bindings, scopeTypes);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If a new binding matching the catch parameter name was
created while scanning the catch body, ignore it because it
actually refers to the catch parameter and not the outer
scope that we&#39;re currently scanning.</p></div></div><div class="code"><div class="wrapper">                <span class="hljs-keyword">if</span> (!hadBinding) {
                    <span class="hljs-keyword">delete</span> bindings[catchParamName];
                }
            }

        } <span class="hljs-keyword">else</span> {
            recursiveScanScope(path, bindings, scopeTypes);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addPattern</span>(<span class="hljs-params">patternPath, bindings</span>) </span>{
        <span class="hljs-keyword">var</span> pattern = patternPath.value;
        namedTypes.Pattern.assert(pattern);

        <span class="hljs-keyword">if</span> (namedTypes.Identifier.check(pattern)) {
            <span class="hljs-keyword">if</span> (hasOwn.call(bindings, pattern.name)) {
                bindings[pattern.name].push(patternPath);
            } <span class="hljs-keyword">else</span> {
                bindings[pattern.name] = [patternPath];
            }

        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (namedTypes.ObjectPattern &amp;&amp;
          namedTypes.ObjectPattern.check(pattern)) {
            patternPath.get(<span class="hljs-string">'properties'</span>).each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">propertyPath</span>) </span>{
                <span class="hljs-keyword">var</span> property = propertyPath.value;
                <span class="hljs-keyword">if</span> (namedTypes.Pattern.check(property)) {
                    addPattern(propertyPath, bindings);
                } <span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span> (namedTypes.Property.check(property)) {
                    addPattern(propertyPath.get(<span class="hljs-string">'value'</span>), bindings);
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (namedTypes.SpreadProperty &amp;&amp;
                  namedTypes.SpreadProperty.check(property)) {
                    addPattern(propertyPath.get(<span class="hljs-string">'argument'</span>), bindings);
                }
            });

        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (namedTypes.ArrayPattern &amp;&amp;
          namedTypes.ArrayPattern.check(pattern)) {
            patternPath.get(<span class="hljs-string">'elements'</span>).each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elementPath</span>) </span>{
                <span class="hljs-keyword">var</span> element = elementPath.value;
                <span class="hljs-keyword">if</span> (namedTypes.Pattern.check(element)) {
                    addPattern(elementPath, bindings);
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (namedTypes.SpreadElement &amp;&amp;
                  namedTypes.SpreadElement.check(element)) {
                    addPattern(elementPath.get(<span class="hljs-string">"argument"</span>), bindings);
                }
            });

        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (namedTypes.PropertyPattern &amp;&amp;
          namedTypes.PropertyPattern.check(pattern)) {
            addPattern(patternPath.get(<span class="hljs-string">'pattern'</span>), bindings);

        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((namedTypes.SpreadElementPattern &amp;&amp;
          namedTypes.SpreadElementPattern.check(pattern)) ||
          (namedTypes.SpreadPropertyPattern &amp;&amp;
          namedTypes.SpreadPropertyPattern.check(pattern))) {
            addPattern(patternPath.get(<span class="hljs-string">'argument'</span>), bindings);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addTypePattern</span>(<span class="hljs-params">patternPath, types</span>) </span>{
        <span class="hljs-keyword">var</span> pattern = patternPath.value;
        namedTypes.Pattern.assert(pattern);

        <span class="hljs-keyword">if</span> (namedTypes.Identifier.check(pattern)) {
            <span class="hljs-keyword">if</span> (hasOwn.call(types, pattern.name)) {
                types[pattern.name].push(patternPath);
            } <span class="hljs-keyword">else</span> {
                types[pattern.name] = [patternPath];
            }

        }
    }

    Sp.lookup = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> scope = <span class="hljs-keyword">this</span>; scope; scope = scope.parent)
            <span class="hljs-keyword">if</span> (scope.declares(name))
                <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">return</span> scope;
    };

    Sp.lookupType = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> scope = <span class="hljs-keyword">this</span>; scope; scope = scope.parent)
            <span class="hljs-keyword">if</span> (scope.declaresType(name))
                <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">return</span> scope;
    };

    Sp.getGlobalScope = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> scope = <span class="hljs-keyword">this</span>;
        <span class="hljs-keyword">while</span> (!scope.isGlobal)
            scope = scope.parent;
        <span class="hljs-keyword">return</span> scope;
    };

    <span class="hljs-keyword">return</span> Scope;
};</div></div></div></div></body></html>