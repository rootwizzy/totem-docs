<!DOCTYPE html><html lang="en"><head><title>thinkspace/client/thinkspace-common/node_modules/ast-types/lib/node-path</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../../../../../../"><meta name="groc-document-path" content="thinkspace/client/thinkspace-common/node_modules/ast-types/lib/node-path"><meta name="groc-project-path" content="src/thinkspace/client/thinkspace-common/node_modules/ast-types/lib/node-path.js"><meta name="groc-branch-path" content="master"><meta name="groc-github-url" content="https://github.com/sixthedge/cellar"><link rel="stylesheet" type="text/css" media="all" href="../../../../../../assets/style.css"><script type="text/javascript" src="../../../../../../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/sixthedge/cellar/blob/master/src/thinkspace/client/thinkspace-common/node_modules/ast-types/lib/node-path.js">src/thinkspace/client/thinkspace-common/node_modules/ast-types/lib/node-path.js</a></div></div><div id="document"><a href="/" class="lodestar-link">Back to Guides</a><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fork</span>) </span>{
    <span class="hljs-keyword">var</span> types = fork.use(<span class="hljs-built_in">require</span>(<span class="hljs-string">"./types"</span>));
    <span class="hljs-keyword">var</span> n = types.namedTypes;
    <span class="hljs-keyword">var</span> b = types.builders;
    <span class="hljs-keyword">var</span> isNumber = types.builtInTypes.number;
    <span class="hljs-keyword">var</span> isArray = types.builtInTypes.array;
    <span class="hljs-keyword">var</span> Path = fork.use(<span class="hljs-built_in">require</span>(<span class="hljs-string">"./path"</span>));
    <span class="hljs-keyword">var</span> Scope = fork.use(<span class="hljs-built_in">require</span>(<span class="hljs-string">"./scope"</span>));

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">NodePath</span>(<span class="hljs-params">value, parentPath, name</span>) </span>{
        <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> NodePath)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"NodePath constructor cannot be invoked without 'new'"</span>);
        }
        Path.call(<span class="hljs-keyword">this</span>, value, parentPath, name);
    }

    <span class="hljs-keyword">var</span> NPp = NodePath.prototype = <span class="hljs-built_in">Object</span>.create(Path.prototype, {
        constructor: {
            value: NodePath,
            enumerable: <span class="hljs-literal">false</span>,
            writable: <span class="hljs-literal">true</span>,
            configurable: <span class="hljs-literal">true</span>
        }
    });

    <span class="hljs-built_in">Object</span>.defineProperties(NPp, {
        node: {
            get: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-keyword">this</span>, <span class="hljs-string">"node"</span>, {
                    configurable: <span class="hljs-literal">true</span>, <span class="hljs-comment">// Enable deletion.</span>
                    value: <span class="hljs-keyword">this</span>._computeNode()
                });

                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.node;
            }
        },

        parent: {
            get: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-keyword">this</span>, <span class="hljs-string">"parent"</span>, {
                    configurable: <span class="hljs-literal">true</span>, <span class="hljs-comment">// Enable deletion.</span>
                    value: <span class="hljs-keyword">this</span>._computeParent()
                });

                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parent;
            }
        },

        scope: {
            get: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-keyword">this</span>, <span class="hljs-string">"scope"</span>, {
                    configurable: <span class="hljs-literal">true</span>, <span class="hljs-comment">// Enable deletion.</span>
                    value: <span class="hljs-keyword">this</span>._computeScope()
                });

                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.scope;
            }
        }
    });

    NPp.replace = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.node;
        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.parent;
        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.scope;
        <span class="hljs-keyword">return</span> Path.prototype.replace.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    };

    NPp.prune = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> remainingNodePath = <span class="hljs-keyword">this</span>.parent;

        <span class="hljs-keyword">this</span>.replace();

        <span class="hljs-keyword">return</span> cleanUpNodesAfterPrune(remainingNodePath);
    };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The value of the first ancestor Path whose value is a Node.</p></div></div><div class="code"><div class="wrapper">    NPp._computeNode = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> value = <span class="hljs-keyword">this</span>.value;
        <span class="hljs-keyword">if</span> (n.Node.check(value)) {
            <span class="hljs-keyword">return</span> value;
        }

        <span class="hljs-keyword">var</span> pp = <span class="hljs-keyword">this</span>.parentPath;
        <span class="hljs-keyword">return</span> pp &amp;&amp; pp.node || <span class="hljs-literal">null</span>;
    };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The first ancestor Path whose value is a Node distinct from this.node.</p></div></div><div class="code"><div class="wrapper">    NPp._computeParent = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> value = <span class="hljs-keyword">this</span>.value;
        <span class="hljs-keyword">var</span> pp = <span class="hljs-keyword">this</span>.parentPath;

        <span class="hljs-keyword">if</span> (!n.Node.check(value)) {
            <span class="hljs-keyword">while</span> (pp &amp;&amp; !n.Node.check(pp.value)) {
                pp = pp.parentPath;
            }

            <span class="hljs-keyword">if</span> (pp) {
                pp = pp.parentPath;
            }
        }

        <span class="hljs-keyword">while</span> (pp &amp;&amp; !n.Node.check(pp.value)) {
            pp = pp.parentPath;
        }

        <span class="hljs-keyword">return</span> pp || <span class="hljs-literal">null</span>;
    };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The closest enclosing scope that governs this node.</p></div></div><div class="code"><div class="wrapper">    NPp._computeScope = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> value = <span class="hljs-keyword">this</span>.value;
        <span class="hljs-keyword">var</span> pp = <span class="hljs-keyword">this</span>.parentPath;
        <span class="hljs-keyword">var</span> scope = pp &amp;&amp; pp.scope;

        <span class="hljs-keyword">if</span> (n.Node.check(value) &amp;&amp;
          Scope.isEstablishedBy(value)) {
            scope = <span class="hljs-keyword">new</span> Scope(<span class="hljs-keyword">this</span>, scope);
        }

        <span class="hljs-keyword">return</span> scope || <span class="hljs-literal">null</span>;
    };

    NPp.getValueProperty = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">return</span> types.getFieldValue(<span class="hljs-keyword">this</span>.value, name);
    };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Determine whether this.node needs to be wrapped in parentheses in order
for a parser to reproduce the same local AST structure.</p>
<p>For instance, in the expression <code>(1 + 2) * 3</code>, the BinaryExpression
whose operator is &quot;+&quot; needs parentheses, because <code>1 + 2 * 3</code> would
parse differently.</p>
<p>If assumeExpressionContext === true, we don&#39;t worry about edge cases
like an anonymous FunctionExpression appearing lexically first in its
enclosing statement and thus needing parentheses to avoid being parsed
as a FunctionDeclaration with a missing name.</p></div></div><div class="code"><div class="wrapper">    NPp.needsParens = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">assumeExpressionContext</span>) </span>{
        <span class="hljs-keyword">var</span> pp = <span class="hljs-keyword">this</span>.parentPath;
        <span class="hljs-keyword">if</span> (!pp) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>.value;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Only expressions need parentheses.</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">if</span> (!n.Expression.check(node)) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Identifiers never need parentheses.</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">"Identifier"</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">while</span> (!n.Node.check(pp.value)) {
            pp = pp.parentPath;
            <span class="hljs-keyword">if</span> (!pp) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
        }

        <span class="hljs-keyword">var</span> parent = pp.value;

        <span class="hljs-keyword">switch</span> (node.type) {
            <span class="hljs-keyword">case</span> <span class="hljs-string">"UnaryExpression"</span>:
            <span class="hljs-keyword">case</span> <span class="hljs-string">"SpreadElement"</span>:
            <span class="hljs-keyword">case</span> <span class="hljs-string">"SpreadProperty"</span>:
                <span class="hljs-keyword">return</span> parent.type === <span class="hljs-string">"MemberExpression"</span>
                  &amp;&amp; <span class="hljs-keyword">this</span>.name === <span class="hljs-string">"object"</span>
                  &amp;&amp; parent.object === node;

            <span class="hljs-keyword">case</span> <span class="hljs-string">"BinaryExpression"</span>:
            <span class="hljs-keyword">case</span> <span class="hljs-string">"LogicalExpression"</span>:
                <span class="hljs-keyword">switch</span> (parent.type) {
                    <span class="hljs-keyword">case</span> <span class="hljs-string">"CallExpression"</span>:
                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name === <span class="hljs-string">"callee"</span>
                          &amp;&amp; parent.callee === node;

                    <span class="hljs-keyword">case</span> <span class="hljs-string">"UnaryExpression"</span>:
                    <span class="hljs-keyword">case</span> <span class="hljs-string">"SpreadElement"</span>:
                    <span class="hljs-keyword">case</span> <span class="hljs-string">"SpreadProperty"</span>:
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

                    <span class="hljs-keyword">case</span> <span class="hljs-string">"MemberExpression"</span>:
                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name === <span class="hljs-string">"object"</span>
                          &amp;&amp; parent.object === node;

                    <span class="hljs-keyword">case</span> <span class="hljs-string">"BinaryExpression"</span>:
                    <span class="hljs-keyword">case</span> <span class="hljs-string">"LogicalExpression"</span>:
                        <span class="hljs-keyword">var</span> po = parent.operator;
                        <span class="hljs-keyword">var</span> pp = PRECEDENCE[po];
                        <span class="hljs-keyword">var</span> no = node.operator;
                        <span class="hljs-keyword">var</span> np = PRECEDENCE[no];

                        <span class="hljs-keyword">if</span> (pp &gt; np) {
                            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                        }

                        <span class="hljs-keyword">if</span> (pp === np &amp;&amp; <span class="hljs-keyword">this</span>.name === <span class="hljs-string">"right"</span>) {
                            <span class="hljs-keyword">if</span> (parent.right !== node) {
                                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Nodes must be equal"</span>);
                            }
                            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                        }

                    <span class="hljs-keyword">default</span>:
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }

            <span class="hljs-keyword">case</span> <span class="hljs-string">"SequenceExpression"</span>:
                <span class="hljs-keyword">switch</span> (parent.type) {
                    <span class="hljs-keyword">case</span> <span class="hljs-string">"ForStatement"</span>:</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Although parentheses wouldn&#39;t hurt around sequence
expressions in the head of for loops, traditional style
dictates that e.g. i++, j++ should not be wrapped with
parentheses.</p></div></div><div class="code"><div class="wrapper">                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

                    <span class="hljs-keyword">case</span> <span class="hljs-string">"ExpressionStatement"</span>:
                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name !== <span class="hljs-string">"expression"</span>;

                    <span class="hljs-keyword">default</span>:</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Otherwise err on the side of overparenthesization, adding
explicit exceptions above if this proves overzealous.</p></div></div><div class="code"><div class="wrapper">                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                }

            <span class="hljs-keyword">case</span> <span class="hljs-string">"YieldExpression"</span>:
                <span class="hljs-keyword">switch</span> (parent.type) {
                    <span class="hljs-keyword">case</span> <span class="hljs-string">"BinaryExpression"</span>:
                    <span class="hljs-keyword">case</span> <span class="hljs-string">"LogicalExpression"</span>:
                    <span class="hljs-keyword">case</span> <span class="hljs-string">"UnaryExpression"</span>:
                    <span class="hljs-keyword">case</span> <span class="hljs-string">"SpreadElement"</span>:
                    <span class="hljs-keyword">case</span> <span class="hljs-string">"SpreadProperty"</span>:
                    <span class="hljs-keyword">case</span> <span class="hljs-string">"CallExpression"</span>:
                    <span class="hljs-keyword">case</span> <span class="hljs-string">"MemberExpression"</span>:
                    <span class="hljs-keyword">case</span> <span class="hljs-string">"NewExpression"</span>:
                    <span class="hljs-keyword">case</span> <span class="hljs-string">"ConditionalExpression"</span>:
                    <span class="hljs-keyword">case</span> <span class="hljs-string">"YieldExpression"</span>:
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

                    <span class="hljs-keyword">default</span>:
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }

            <span class="hljs-keyword">case</span> <span class="hljs-string">"Literal"</span>:
                <span class="hljs-keyword">return</span> parent.type === <span class="hljs-string">"MemberExpression"</span>
                  &amp;&amp; isNumber.check(node.value)
                  &amp;&amp; <span class="hljs-keyword">this</span>.name === <span class="hljs-string">"object"</span>
                  &amp;&amp; parent.object === node;

            <span class="hljs-keyword">case</span> <span class="hljs-string">"AssignmentExpression"</span>:
            <span class="hljs-keyword">case</span> <span class="hljs-string">"ConditionalExpression"</span>:
                <span class="hljs-keyword">switch</span> (parent.type) {
                    <span class="hljs-keyword">case</span> <span class="hljs-string">"UnaryExpression"</span>:
                    <span class="hljs-keyword">case</span> <span class="hljs-string">"SpreadElement"</span>:
                    <span class="hljs-keyword">case</span> <span class="hljs-string">"SpreadProperty"</span>:
                    <span class="hljs-keyword">case</span> <span class="hljs-string">"BinaryExpression"</span>:
                    <span class="hljs-keyword">case</span> <span class="hljs-string">"LogicalExpression"</span>:
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

                    <span class="hljs-keyword">case</span> <span class="hljs-string">"CallExpression"</span>:
                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name === <span class="hljs-string">"callee"</span>
                          &amp;&amp; parent.callee === node;

                    <span class="hljs-keyword">case</span> <span class="hljs-string">"ConditionalExpression"</span>:
                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name === <span class="hljs-string">"test"</span>
                          &amp;&amp; parent.test === node;

                    <span class="hljs-keyword">case</span> <span class="hljs-string">"MemberExpression"</span>:
                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name === <span class="hljs-string">"object"</span>
                          &amp;&amp; parent.object === node;

                    <span class="hljs-keyword">default</span>:
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }

            <span class="hljs-keyword">default</span>:
                <span class="hljs-keyword">if</span> (parent.type === <span class="hljs-string">"NewExpression"</span> &amp;&amp;
                  <span class="hljs-keyword">this</span>.name === <span class="hljs-string">"callee"</span> &amp;&amp;
                  parent.callee === node) {
                    <span class="hljs-keyword">return</span> containsCallExpression(node);
                }
        }

        <span class="hljs-keyword">if</span> (assumeExpressionContext !== <span class="hljs-literal">true</span> &amp;&amp;
          !<span class="hljs-keyword">this</span>.canBeFirstInStatement() &amp;&amp;
          <span class="hljs-keyword">this</span>.firstInStatement())
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isBinary</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">return</span> n.BinaryExpression.check(node)
          || n.LogicalExpression.check(node);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isUnaryLike</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">return</span> n.UnaryExpression.check(node)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>I considered making SpreadElement and SpreadProperty subtypes
of UnaryExpression, but they&#39;re not really Expression nodes.</p></div></div><div class="code"><div class="wrapper">          || (n.SpreadElement &amp;&amp; n.SpreadElement.check(node))
          || (n.SpreadProperty &amp;&amp; n.SpreadProperty.check(node));
    }

    <span class="hljs-keyword">var</span> PRECEDENCE = {};
    [[<span class="hljs-string">"||"</span>],
        [<span class="hljs-string">"&amp;&amp;"</span>],
        [<span class="hljs-string">"|"</span>],
        [<span class="hljs-string">"^"</span>],
        [<span class="hljs-string">"&amp;"</span>],
        [<span class="hljs-string">"=="</span>, <span class="hljs-string">"==="</span>, <span class="hljs-string">"!="</span>, <span class="hljs-string">"!=="</span>],
        [<span class="hljs-string">"&lt;"</span>, <span class="hljs-string">"&gt;"</span>, <span class="hljs-string">"&lt;="</span>, <span class="hljs-string">"&gt;="</span>, <span class="hljs-string">"in"</span>, <span class="hljs-string">"instanceof"</span>],
        [<span class="hljs-string">"&gt;&gt;"</span>, <span class="hljs-string">"&lt;&lt;"</span>, <span class="hljs-string">"&gt;&gt;&gt;"</span>],
        [<span class="hljs-string">"+"</span>, <span class="hljs-string">"-"</span>],
        [<span class="hljs-string">"*"</span>, <span class="hljs-string">"/"</span>, <span class="hljs-string">"%"</span>]
    ].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">tier, i</span>) </span>{
        tier.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">op</span>) </span>{
            PRECEDENCE[op] = i;
        });
    });

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">containsCallExpression</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">if</span> (n.CallExpression.check(node)) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">if</span> (isArray.check(node)) {
            <span class="hljs-keyword">return</span> node.some(containsCallExpression);
        }

        <span class="hljs-keyword">if</span> (n.Node.check(node)) {
            <span class="hljs-keyword">return</span> types.someField(node, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, child</span>) </span>{
                <span class="hljs-keyword">return</span> containsCallExpression(child);
            });
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    NPp.canBeFirstInStatement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>.node;
        <span class="hljs-keyword">return</span> !n.FunctionExpression.check(node)
          &amp;&amp; !n.ObjectExpression.check(node);
    };

    NPp.firstInStatement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> firstInStatement(<span class="hljs-keyword">this</span>);
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">firstInStatement</span>(<span class="hljs-params">path</span>) </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> node, parent; path.parent; path = path.parent) {
            node = path.node;
            parent = path.parent.node;

            <span class="hljs-keyword">if</span> (n.BlockStatement.check(parent) &amp;&amp;
              path.parent.name === <span class="hljs-string">"body"</span> &amp;&amp;
              path.name === <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">if</span> (parent.body[<span class="hljs-number">0</span>] !== node) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Nodes must be equal"</span>);
                }
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }

            <span class="hljs-keyword">if</span> (n.ExpressionStatement.check(parent) &amp;&amp;
              path.name === <span class="hljs-string">"expression"</span>) {
                <span class="hljs-keyword">if</span> (parent.expression !== node) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Nodes must be equal"</span>);
                }
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }

            <span class="hljs-keyword">if</span> (n.SequenceExpression.check(parent) &amp;&amp;
              path.parent.name === <span class="hljs-string">"expressions"</span> &amp;&amp;
              path.name === <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">if</span> (parent.expressions[<span class="hljs-number">0</span>] !== node) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Nodes must be equal"</span>);
                }
                <span class="hljs-keyword">continue</span>;
            }

            <span class="hljs-keyword">if</span> (n.CallExpression.check(parent) &amp;&amp;
              path.name === <span class="hljs-string">"callee"</span>) {
                <span class="hljs-keyword">if</span> (parent.callee !== node) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Nodes must be equal"</span>);
                }
                <span class="hljs-keyword">continue</span>;
            }

            <span class="hljs-keyword">if</span> (n.MemberExpression.check(parent) &amp;&amp;
              path.name === <span class="hljs-string">"object"</span>) {
                <span class="hljs-keyword">if</span> (parent.object !== node) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Nodes must be equal"</span>);
                }
                <span class="hljs-keyword">continue</span>;
            }

            <span class="hljs-keyword">if</span> (n.ConditionalExpression.check(parent) &amp;&amp;
              path.name === <span class="hljs-string">"test"</span>) {
                <span class="hljs-keyword">if</span> (parent.test !== node) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Nodes must be equal"</span>);
                }
                <span class="hljs-keyword">continue</span>;
            }

            <span class="hljs-keyword">if</span> (isBinary(parent) &amp;&amp;
              path.name === <span class="hljs-string">"left"</span>) {
                <span class="hljs-keyword">if</span> (parent.left !== node) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Nodes must be equal"</span>);
                }
                <span class="hljs-keyword">continue</span>;
            }

            <span class="hljs-keyword">if</span> (n.UnaryExpression.check(parent) &amp;&amp;
              !parent.prefix &amp;&amp;
              path.name === <span class="hljs-string">"argument"</span>) {
                <span class="hljs-keyword">if</span> (parent.argument !== node) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Nodes must be equal"</span>);
                }
                <span class="hljs-keyword">continue</span>;
            }

            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Pruning certain nodes will result in empty or incomplete nodes, here we clean those nodes up.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cleanUpNodesAfterPrune</span>(<span class="hljs-params">remainingNodePath</span>) </span>{
        <span class="hljs-keyword">if</span> (n.VariableDeclaration.check(remainingNodePath.node)) {
            <span class="hljs-keyword">var</span> declarations = remainingNodePath.get(<span class="hljs-string">'declarations'</span>).value;
            <span class="hljs-keyword">if</span> (!declarations || declarations.length === <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">return</span> remainingNodePath.prune();
            }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n.ExpressionStatement.check(remainingNodePath.node)) {
            <span class="hljs-keyword">if</span> (!remainingNodePath.get(<span class="hljs-string">'expression'</span>).value) {
                <span class="hljs-keyword">return</span> remainingNodePath.prune();
            }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n.IfStatement.check(remainingNodePath.node)) {
            cleanUpIfStatementAfterPrune(remainingNodePath);
        }

        <span class="hljs-keyword">return</span> remainingNodePath;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cleanUpIfStatementAfterPrune</span>(<span class="hljs-params">ifStatement</span>) </span>{
        <span class="hljs-keyword">var</span> testExpression = ifStatement.get(<span class="hljs-string">'test'</span>).value;
        <span class="hljs-keyword">var</span> alternate = ifStatement.get(<span class="hljs-string">'alternate'</span>).value;
        <span class="hljs-keyword">var</span> consequent = ifStatement.get(<span class="hljs-string">'consequent'</span>).value;

        <span class="hljs-keyword">if</span> (!consequent &amp;&amp; !alternate) {
            <span class="hljs-keyword">var</span> testExpressionStatement = b.expressionStatement(testExpression);

            ifStatement.replace(testExpressionStatement);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!consequent &amp;&amp; alternate) {
            <span class="hljs-keyword">var</span> negatedTestExpression = b.unaryExpression(<span class="hljs-string">'!'</span>, testExpression, <span class="hljs-literal">true</span>);

            <span class="hljs-keyword">if</span> (n.UnaryExpression.check(testExpression) &amp;&amp; testExpression.operator === <span class="hljs-string">'!'</span>) {
                negatedTestExpression = testExpression.argument;
            }

            ifStatement.get(<span class="hljs-string">"test"</span>).replace(negatedTestExpression);
            ifStatement.get(<span class="hljs-string">"consequent"</span>).replace(alternate);
            ifStatement.get(<span class="hljs-string">"alternate"</span>).replace();
        }
    }

    <span class="hljs-keyword">return</span> NodePath;
};</div></div></div></div></body></html>