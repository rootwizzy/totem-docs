<!DOCTYPE html><html lang="en"><head><title>thinkspace/client/thinkspace-common/node_modules/ast-types/lib/path-visitor</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../../../../../../"><meta name="groc-document-path" content="thinkspace/client/thinkspace-common/node_modules/ast-types/lib/path-visitor"><meta name="groc-project-path" content="src/thinkspace/client/thinkspace-common/node_modules/ast-types/lib/path-visitor.js"><meta name="groc-branch-path" content="master"><meta name="groc-github-url" content="https://github.com/sixthedge/cellar"><link rel="stylesheet" type="text/css" media="all" href="../../../../../../assets/style.css"><script type="text/javascript" src="../../../../../../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/sixthedge/cellar/blob/master/src/thinkspace/client/thinkspace-common/node_modules/ast-types/lib/path-visitor.js">src/thinkspace/client/thinkspace-common/node_modules/ast-types/lib/path-visitor.js</a></div></div><div id="document"><a href="/" class="lodestar-link">Back to Guides</a><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> hasOwn = <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty;

<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fork</span>) </span>{
    <span class="hljs-keyword">var</span> types = fork.use(<span class="hljs-built_in">require</span>(<span class="hljs-string">"./types"</span>));
    <span class="hljs-keyword">var</span> NodePath = fork.use(<span class="hljs-built_in">require</span>(<span class="hljs-string">"./node-path"</span>));
    <span class="hljs-keyword">var</span> Printable = types.namedTypes.Printable;
    <span class="hljs-keyword">var</span> isArray = types.builtInTypes.array;
    <span class="hljs-keyword">var</span> isObject = types.builtInTypes.object;
    <span class="hljs-keyword">var</span> isFunction = types.builtInTypes.function;
    <span class="hljs-keyword">var</span> <span class="hljs-literal">undefined</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PathVisitor</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> PathVisitor)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(
              <span class="hljs-string">"PathVisitor constructor cannot be invoked without 'new'"</span>
            );
        }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Permanent state.</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">this</span>._reusableContextStack = [];

        <span class="hljs-keyword">this</span>._methodNameTable = computeMethodNameTable(<span class="hljs-keyword">this</span>);
        <span class="hljs-keyword">this</span>._shouldVisitComments =
          hasOwn.call(<span class="hljs-keyword">this</span>._methodNameTable, <span class="hljs-string">"Block"</span>) ||
          hasOwn.call(<span class="hljs-keyword">this</span>._methodNameTable, <span class="hljs-string">"Line"</span>);

        <span class="hljs-keyword">this</span>.Context = makeContextConstructor(<span class="hljs-keyword">this</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>State reset every time PathVisitor.prototype.visit is called.</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">this</span>._visiting = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">this</span>._changeReported = <span class="hljs-literal">false</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computeMethodNameTable</span>(<span class="hljs-params">visitor</span>) </span>{
        <span class="hljs-keyword">var</span> typeNames = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> methodName <span class="hljs-keyword">in</span> visitor) {
            <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^visit[A-Z]/</span>.test(methodName)) {
                typeNames[methodName.slice(<span class="hljs-string">"visit"</span>.length)] = <span class="hljs-literal">true</span>;
            }
        }

        <span class="hljs-keyword">var</span> supertypeTable = types.computeSupertypeLookupTable(typeNames);
        <span class="hljs-keyword">var</span> methodNameTable = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);

        <span class="hljs-keyword">var</span> typeNames = <span class="hljs-built_in">Object</span>.keys(supertypeTable);
        <span class="hljs-keyword">var</span> typeNameCount = typeNames.length;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; typeNameCount; ++i) {
            <span class="hljs-keyword">var</span> typeName = typeNames[i];
            methodName = <span class="hljs-string">"visit"</span> + supertypeTable[typeName];
            <span class="hljs-keyword">if</span> (isFunction.check(visitor[methodName])) {
                methodNameTable[typeName] = methodName;
            }
        }

        <span class="hljs-keyword">return</span> methodNameTable;
    }

    PathVisitor.fromMethodsObject = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fromMethodsObject</span>(<span class="hljs-params">methods</span>) </span>{
        <span class="hljs-keyword">if</span> (methods <span class="hljs-keyword">instanceof</span> PathVisitor) {
            <span class="hljs-keyword">return</span> methods;
        }

        <span class="hljs-keyword">if</span> (!isObject.check(methods)) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>An empty visitor?</p></div></div><div class="code"><div class="wrapper">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PathVisitor;
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Visitor</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Visitor)) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(
                  <span class="hljs-string">"Visitor constructor cannot be invoked without 'new'"</span>
                );
            }
            PathVisitor.call(<span class="hljs-keyword">this</span>);
        }

        <span class="hljs-keyword">var</span> Vp = Visitor.prototype = <span class="hljs-built_in">Object</span>.create(PVp);
        Vp.constructor = Visitor;

        extend(Vp, methods);
        extend(Visitor, PathVisitor);

        isFunction.assert(Visitor.fromMethodsObject);
        isFunction.assert(Visitor.visit);

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Visitor;
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extend</span>(<span class="hljs-params">target, source</span>) </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> property <span class="hljs-keyword">in</span> source) {
            <span class="hljs-keyword">if</span> (hasOwn.call(source, property)) {
                target[property] = source[property];
            }
        }

        <span class="hljs-keyword">return</span> target;
    }

    PathVisitor.visit = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visit</span>(<span class="hljs-params">node, methods</span>) </span>{
        <span class="hljs-keyword">return</span> PathVisitor.fromMethodsObject(methods).visit(node);
    };

    <span class="hljs-keyword">var</span> PVp = PathVisitor.prototype;

    PVp.visit = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._visiting) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(
              <span class="hljs-string">"Recursively calling visitor.visit(path) resets visitor state. "</span> +
              <span class="hljs-string">"Try this.visit(path) or this.traverse(path) instead."</span>
            );
        }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Private state that needs to be reset before every traversal.</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">this</span>._visiting = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">this</span>._changeReported = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">this</span>._abortRequested = <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">var</span> argc = <span class="hljs-built_in">arguments</span>.length;
        <span class="hljs-keyword">var</span> args = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(argc)
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; argc; ++i) {
            args[i] = <span class="hljs-built_in">arguments</span>[i];
        }

        <span class="hljs-keyword">if</span> (!(args[<span class="hljs-number">0</span>] <span class="hljs-keyword">instanceof</span> NodePath)) {
            args[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> NodePath({root: args[<span class="hljs-number">0</span>]}).get(<span class="hljs-string">"root"</span>);
        }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Called with the same arguments as .visit.</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">this</span>.reset.apply(<span class="hljs-keyword">this</span>, args);

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">var</span> root = <span class="hljs-keyword">this</span>.visitWithoutReset(args[<span class="hljs-number">0</span>]);
            <span class="hljs-keyword">var</span> didNotThrow = <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">this</span>._visiting = <span class="hljs-literal">false</span>;

            <span class="hljs-keyword">if</span> (!didNotThrow &amp;&amp; <span class="hljs-keyword">this</span>._abortRequested) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If this.visitWithoutReset threw an exception and
this._abortRequested was set to true, return the root of
the AST instead of letting the exception propagate, so that
client code does not have to provide a try-catch block to
intercept the AbortRequest exception.  Other kinds of
exceptions will propagate without being intercepted and
rethrown by a catch block, so their stacks will accurately
reflect the original throwing context.</p></div></div><div class="code"><div class="wrapper">                <span class="hljs-keyword">return</span> args[<span class="hljs-number">0</span>].value;
            }
        }

        <span class="hljs-keyword">return</span> root;
    };

    PVp.AbortRequest = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AbortRequest</span>(<span class="hljs-params"></span>) </span>{};
    PVp.abort = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> visitor = <span class="hljs-keyword">this</span>;
        visitor._abortRequested = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">var</span> request = <span class="hljs-keyword">new</span> visitor.AbortRequest();</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If you decide to catch this exception and stop it from propagating,
make sure to call its cancel method to avoid silencing other
exceptions that might be thrown later in the traversal.</p></div></div><div class="code"><div class="wrapper">        request.cancel = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            visitor._abortRequested = <span class="hljs-literal">false</span>;
        };

        <span class="hljs-keyword">throw</span> request;
    };

    PVp.reset = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">path<span class="hljs-comment">/*, additional arguments */</span></span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Empty stub; may be reassigned or overridden by subclasses.</p></div></div><div class="code"><div class="wrapper">    };

    PVp.visitWithoutReset = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">path</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-keyword">this</span>.Context) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Since this.Context.prototype === this, there&#39;s a chance we
might accidentally call context.visitWithoutReset. If that
happens, re-invoke the method against context.visitor.</p></div></div><div class="code"><div class="wrapper">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.visitor.visitWithoutReset(path);
        }

        <span class="hljs-keyword">if</span> (!(path <span class="hljs-keyword">instanceof</span> NodePath)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
        }

        <span class="hljs-keyword">var</span> value = path.value;

        <span class="hljs-keyword">var</span> methodName = value &amp;&amp;
          <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">"object"</span> &amp;&amp;
          <span class="hljs-keyword">typeof</span> value.type === <span class="hljs-string">"string"</span> &amp;&amp;
          <span class="hljs-keyword">this</span>._methodNameTable[value.type];

        <span class="hljs-keyword">if</span> (methodName) {
            <span class="hljs-keyword">var</span> context = <span class="hljs-keyword">this</span>.acquireContext(path);
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> context.invokeVisitorMethod(methodName);
            } <span class="hljs-keyword">finally</span> {
                <span class="hljs-keyword">this</span>.releaseContext(context);
            }

        } <span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If there was no visitor method to call, visit the children of
this node generically.</p></div></div><div class="code"><div class="wrapper">            <span class="hljs-keyword">return</span> visitChildren(path, <span class="hljs-keyword">this</span>);
        }
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitChildren</span>(<span class="hljs-params">path, visitor</span>) </span>{
        <span class="hljs-keyword">if</span> (!(path <span class="hljs-keyword">instanceof</span> NodePath)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
        }
        <span class="hljs-keyword">if</span> (!(visitor <span class="hljs-keyword">instanceof</span> PathVisitor)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
        }

        <span class="hljs-keyword">var</span> value = path.value;

        <span class="hljs-keyword">if</span> (isArray.check(value)) {
            path.each(visitor.visitWithoutReset, visitor);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isObject.check(value)) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>No children to visit.</p></div></div><div class="code"><div class="wrapper">        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">var</span> childNames = types.getFieldNames(value);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The .comments field of the Node type is hidden, so we only
visit it if the visitor defines visitBlock or visitLine, and
value.comments is defined.</p></div></div><div class="code"><div class="wrapper">            <span class="hljs-keyword">if</span> (visitor._shouldVisitComments &amp;&amp;
              value.comments &amp;&amp;
              childNames.indexOf(<span class="hljs-string">"comments"</span>) &lt; <span class="hljs-number">0</span>) {
                childNames.push(<span class="hljs-string">"comments"</span>);
            }

            <span class="hljs-keyword">var</span> childCount = childNames.length;
            <span class="hljs-keyword">var</span> childPaths = [];

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; childCount; ++i) {
                <span class="hljs-keyword">var</span> childName = childNames[i];
                <span class="hljs-keyword">if</span> (!hasOwn.call(value, childName)) {
                    value[childName] = types.getFieldValue(value, childName);
                }
                childPaths.push(path.get(childName));
            }

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; childCount; ++i) {
                visitor.visitWithoutReset(childPaths[i]);
            }
        }

        <span class="hljs-keyword">return</span> path.value;
    }

    PVp.acquireContext = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">path</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._reusableContextStack.length === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">this</span>.Context(path);
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._reusableContextStack.pop().reset(path);
    };

    PVp.releaseContext = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context</span>) </span>{
        <span class="hljs-keyword">if</span> (!(context <span class="hljs-keyword">instanceof</span> <span class="hljs-keyword">this</span>.Context)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
        }
        <span class="hljs-keyword">this</span>._reusableContextStack.push(context);
        context.currentPath = <span class="hljs-literal">null</span>;
    };

    PVp.reportChanged = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>._changeReported = <span class="hljs-literal">true</span>;
    };

    PVp.wasChangeReported = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._changeReported;
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeContextConstructor</span>(<span class="hljs-params">visitor</span>) </span>{
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Context</span>(<span class="hljs-params">path</span>) </span>{
            <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Context)) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
            }
            <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> PathVisitor)) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
            }
            <span class="hljs-keyword">if</span> (!(path <span class="hljs-keyword">instanceof</span> NodePath)) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
            }

            <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-keyword">this</span>, <span class="hljs-string">"visitor"</span>, {
                value: visitor,
                writable: <span class="hljs-literal">false</span>,
                enumerable: <span class="hljs-literal">true</span>,
                configurable: <span class="hljs-literal">false</span>
            });

            <span class="hljs-keyword">this</span>.currentPath = path;
            <span class="hljs-keyword">this</span>.needToCallTraverse = <span class="hljs-literal">true</span>;

            <span class="hljs-built_in">Object</span>.seal(<span class="hljs-keyword">this</span>);
        }

        <span class="hljs-keyword">if</span> (!(visitor <span class="hljs-keyword">instanceof</span> PathVisitor)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
        }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Note that the visitor object is the prototype of Context.prototype,
so all visitor methods are inherited by context objects.</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">var</span> Cp = Context.prototype = <span class="hljs-built_in">Object</span>.create(visitor);

        Cp.constructor = Context;
        extend(Cp, sharedContextProtoMethods);

        <span class="hljs-keyword">return</span> Context;
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Every PathVisitor has a different this.Context constructor and
this.Context.prototype object, but those prototypes can all use the
same reset, invokeVisitorMethod, and traverse function objects.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">var</span> sharedContextProtoMethods = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);

    sharedContextProtoMethods.reset =
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reset</span>(<span class="hljs-params">path</span>) </span>{
          <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-keyword">this</span>.Context)) {
              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
          }
          <span class="hljs-keyword">if</span> (!(path <span class="hljs-keyword">instanceof</span> NodePath)) {
              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
          }

          <span class="hljs-keyword">this</span>.currentPath = path;
          <span class="hljs-keyword">this</span>.needToCallTraverse = <span class="hljs-literal">true</span>;

          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      };

    sharedContextProtoMethods.invokeVisitorMethod =
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">invokeVisitorMethod</span>(<span class="hljs-params">methodName</span>) </span>{
          <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-keyword">this</span>.Context)) {
              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
          }
          <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span>.currentPath <span class="hljs-keyword">instanceof</span> NodePath)) {
              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
          }

          <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">this</span>.visitor[methodName].call(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>.currentPath);

          <span class="hljs-keyword">if</span> (result === <span class="hljs-literal">false</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Visitor methods return false to indicate that they have handled
their own traversal needs, and we should not complain if
this.needToCallTraverse is still true.</p></div></div><div class="code"><div class="wrapper">              <span class="hljs-keyword">this</span>.needToCallTraverse = <span class="hljs-literal">false</span>;

          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result !== <span class="hljs-literal">undefined</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Any other non-undefined value returned from the visitor method
is interpreted as a replacement value.</p></div></div><div class="code"><div class="wrapper">              <span class="hljs-keyword">this</span>.currentPath = <span class="hljs-keyword">this</span>.currentPath.replace(result)[<span class="hljs-number">0</span>];

              <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.needToCallTraverse) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If this.traverse still hasn&#39;t been called, visit the
children of the replacement node.</p></div></div><div class="code"><div class="wrapper">                  <span class="hljs-keyword">this</span>.traverse(<span class="hljs-keyword">this</span>.currentPath);
              }
          }

          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.needToCallTraverse !== <span class="hljs-literal">false</span>) {
              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(
                <span class="hljs-string">"Must either call this.traverse or return false in "</span> + methodName
              );
          }

          <span class="hljs-keyword">var</span> path = <span class="hljs-keyword">this</span>.currentPath;
          <span class="hljs-keyword">return</span> path &amp;&amp; path.value;
      };

    sharedContextProtoMethods.traverse =
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traverse</span>(<span class="hljs-params">path, newVisitor</span>) </span>{
          <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-keyword">this</span>.Context)) {
              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
          }
          <span class="hljs-keyword">if</span> (!(path <span class="hljs-keyword">instanceof</span> NodePath)) {
              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
          }
          <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span>.currentPath <span class="hljs-keyword">instanceof</span> NodePath)) {
              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
          }

          <span class="hljs-keyword">this</span>.needToCallTraverse = <span class="hljs-literal">false</span>;

          <span class="hljs-keyword">return</span> visitChildren(path, PathVisitor.fromMethodsObject(
            newVisitor || <span class="hljs-keyword">this</span>.visitor
          ));
      };

    sharedContextProtoMethods.visit =
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visit</span>(<span class="hljs-params">path, newVisitor</span>) </span>{
          <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-keyword">this</span>.Context)) {
              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
          }
          <span class="hljs-keyword">if</span> (!(path <span class="hljs-keyword">instanceof</span> NodePath)) {
              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
          }
          <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span>.currentPath <span class="hljs-keyword">instanceof</span> NodePath)) {
              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span>);
          }

          <span class="hljs-keyword">this</span>.needToCallTraverse = <span class="hljs-literal">false</span>;

          <span class="hljs-keyword">return</span> PathVisitor.fromMethodsObject(
            newVisitor || <span class="hljs-keyword">this</span>.visitor
          ).visitWithoutReset(path);
      };

    sharedContextProtoMethods.reportChanged = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reportChanged</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>.visitor.reportChanged();
    };

    sharedContextProtoMethods.abort = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">abort</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>.needToCallTraverse = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">this</span>.visitor.abort();
    };

    <span class="hljs-keyword">return</span> PathVisitor;
};</div></div></div></div></body></html>