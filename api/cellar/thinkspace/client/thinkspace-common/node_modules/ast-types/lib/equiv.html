<!DOCTYPE html><html lang="en"><head><title>thinkspace/client/thinkspace-common/node_modules/ast-types/lib/equiv</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../../../../../../"><meta name="groc-document-path" content="thinkspace/client/thinkspace-common/node_modules/ast-types/lib/equiv"><meta name="groc-project-path" content="src/thinkspace/client/thinkspace-common/node_modules/ast-types/lib/equiv.js"><meta name="groc-branch-path" content="master"><meta name="groc-github-url" content="https://github.com/sixthedge/cellar"><link rel="stylesheet" type="text/css" media="all" href="../../../../../../assets/style.css"><script type="text/javascript" src="../../../../../../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/sixthedge/cellar/blob/master/src/thinkspace/client/thinkspace-common/node_modules/ast-types/lib/equiv.js">src/thinkspace/client/thinkspace-common/node_modules/ast-types/lib/equiv.js</a></div></div><div id="document"><a href="/" class="lodestar-link">Back to Guides</a><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fork</span>) </span>{
    <span class="hljs-keyword">var</span> types = fork.use(<span class="hljs-built_in">require</span>(<span class="hljs-string">'../lib/types'</span>));
    <span class="hljs-keyword">var</span> getFieldNames = types.getFieldNames;
    <span class="hljs-keyword">var</span> getFieldValue = types.getFieldValue;
    <span class="hljs-keyword">var</span> isArray = types.builtInTypes.array;
    <span class="hljs-keyword">var</span> isObject = types.builtInTypes.object;
    <span class="hljs-keyword">var</span> isDate = types.builtInTypes.Date;
    <span class="hljs-keyword">var</span> isRegExp = types.builtInTypes.RegExp;
    <span class="hljs-keyword">var</span> hasOwn = <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">astNodesAreEquivalent</span>(<span class="hljs-params">a, b, problemPath</span>) </span>{
        <span class="hljs-keyword">if</span> (isArray.check(problemPath)) {
            problemPath.length = <span class="hljs-number">0</span>;
        } <span class="hljs-keyword">else</span> {
            problemPath = <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">return</span> areEquivalent(a, b, problemPath);
    }

    astNodesAreEquivalent.assert = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>{
        <span class="hljs-keyword">var</span> problemPath = [];
        <span class="hljs-keyword">if</span> (!astNodesAreEquivalent(a, b, problemPath)) {
            <span class="hljs-keyword">if</span> (problemPath.length === <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">if</span> (a !== b) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Nodes must be equal"</span>);
                }
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(
                  <span class="hljs-string">"Nodes differ in the following path: "</span> +
                  problemPath.map(subscriptForProperty).join(<span class="hljs-string">""</span>)
                );
            }
        }
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">subscriptForProperty</span>(<span class="hljs-params">property</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/[_$a-z][_$a-z0-9]*/i</span>.test(property)) {
            <span class="hljs-keyword">return</span> <span class="hljs-string">"."</span> + property;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-string">"["</span> + <span class="hljs-built_in">JSON</span>.stringify(property) + <span class="hljs-string">"]"</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">areEquivalent</span>(<span class="hljs-params">a, b, problemPath</span>) </span>{
        <span class="hljs-keyword">if</span> (a === b) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">if</span> (isArray.check(a)) {
            <span class="hljs-keyword">return</span> arraysAreEquivalent(a, b, problemPath);
        }

        <span class="hljs-keyword">if</span> (isObject.check(a)) {
            <span class="hljs-keyword">return</span> objectsAreEquivalent(a, b, problemPath);
        }

        <span class="hljs-keyword">if</span> (isDate.check(a)) {
            <span class="hljs-keyword">return</span> isDate.check(b) &amp;&amp; (+a === +b);
        }

        <span class="hljs-keyword">if</span> (isRegExp.check(a)) {
            <span class="hljs-keyword">return</span> isRegExp.check(b) &amp;&amp; (
                a.source === b.source &amp;&amp;
                a.global === b.global &amp;&amp;
                a.multiline === b.multiline &amp;&amp;
                a.ignoreCase === b.ignoreCase
              );
        }

        <span class="hljs-keyword">return</span> a == b;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">arraysAreEquivalent</span>(<span class="hljs-params">a, b, problemPath</span>) </span>{
        isArray.assert(a);
        <span class="hljs-keyword">var</span> aLength = a.length;

        <span class="hljs-keyword">if</span> (!isArray.check(b) || b.length !== aLength) {
            <span class="hljs-keyword">if</span> (problemPath) {
                problemPath.push(<span class="hljs-string">"length"</span>);
            }
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; aLength; ++i) {
            <span class="hljs-keyword">if</span> (problemPath) {
                problemPath.push(i);
            }

            <span class="hljs-keyword">if</span> (i <span class="hljs-keyword">in</span> a !== i <span class="hljs-keyword">in</span> b) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }

            <span class="hljs-keyword">if</span> (!areEquivalent(a[i], b[i], problemPath)) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }

            <span class="hljs-keyword">if</span> (problemPath) {
                <span class="hljs-keyword">var</span> problemPathTail = problemPath.pop();
                <span class="hljs-keyword">if</span> (problemPathTail !== i) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span> + problemPathTail);
                }
            }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objectsAreEquivalent</span>(<span class="hljs-params">a, b, problemPath</span>) </span>{
        isObject.assert(a);
        <span class="hljs-keyword">if</span> (!isObject.check(b)) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Fast path for a common property of AST nodes.</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">if</span> (a.type !== b.type) {
            <span class="hljs-keyword">if</span> (problemPath) {
                problemPath.push(<span class="hljs-string">"type"</span>);
            }
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">var</span> aNames = getFieldNames(a);
        <span class="hljs-keyword">var</span> aNameCount = aNames.length;

        <span class="hljs-keyword">var</span> bNames = getFieldNames(b);
        <span class="hljs-keyword">var</span> bNameCount = bNames.length;

        <span class="hljs-keyword">if</span> (aNameCount === bNameCount) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; aNameCount; ++i) {
                <span class="hljs-keyword">var</span> name = aNames[i];
                <span class="hljs-keyword">var</span> aChild = getFieldValue(a, name);
                <span class="hljs-keyword">var</span> bChild = getFieldValue(b, name);

                <span class="hljs-keyword">if</span> (problemPath) {
                    problemPath.push(name);
                }

                <span class="hljs-keyword">if</span> (!areEquivalent(aChild, bChild, problemPath)) {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }

                <span class="hljs-keyword">if</span> (problemPath) {
                    <span class="hljs-keyword">var</span> problemPathTail = problemPath.pop();
                    <span class="hljs-keyword">if</span> (problemPathTail !== name) {
                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">""</span> + problemPathTail);
                    }
                }
            }

            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">if</span> (!problemPath) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Since aNameCount !== bNameCount, we need to find some name that&#39;s
missing in aNames but present in bNames, or vice-versa.</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">var</span> seenNames = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);

        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; aNameCount; ++i) {
            seenNames[aNames[i]] = <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; bNameCount; ++i) {
            name = bNames[i];

            <span class="hljs-keyword">if</span> (!hasOwn.call(seenNames, name)) {
                problemPath.push(name);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }

            <span class="hljs-keyword">delete</span> seenNames[name];
        }

        <span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> seenNames) {
            problemPath.push(name);
            <span class="hljs-keyword">break</span>;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    
    <span class="hljs-keyword">return</span> astNodesAreEquivalent;
};</div></div></div></div></body></html>